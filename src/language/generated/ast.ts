/******************************************************************************
 * This file was generated by langium-cli 3.5.2.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const SysMLTerminals = {
    ID: /[a-zA-Z_][a-zA-Z0-9_]*/,
    UNRESTRICTED_NAME: /'([^'\\]|\\.)*'/,
    STRING: /"([^"\\]|\\.)*"/,
    REAL: /[0-9]+\.[0-9]+([eE][+-]?[0-9]+)?|[0-9]+[eE][+-]?[0-9]+/,
    INTEGER: /0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|[0-9]+/,
    COMMENT_BODY: /\/\*\*[\s\S]*?\*\//,
    ML_COMMENT: /\/\*(?!\*)[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
    WS: /\s+/,
};

export type SysMLTerminalNames = keyof typeof SysMLTerminals;

export type SysMLKeywordNames =
    | "!"
    | "!="
    | "!=="
    | "#"
    | "%"
    | "&"
    | "("
    | ")"
    | "*"
    | "**"
    | "+"
    | ","
    | "-"
    | "."
    | ".."
    | "/"
    | ":"
    | "::"
    | "::="
    | ":="
    | ":>"
    | ":>>"
    | ";"
    | "<"
    | "<="
    | "="
    | "=="
    | "==="
    | "=>"
    | ">"
    | ">="
    | "?"
    | "??"
    | "@"
    | "["
    | "]"
    | "^"
    | "about"
    | "abstract"
    | "accept"
    | "action"
    | "actor"
    | "alias"
    | "all"
    | "allocate"
    | "allocation"
    | "analysis"
    | "and"
    | "as"
    | "assert"
    | "assign"
    | "assoc"
    | "assume"
    | "attribute"
    | "behavior"
    | "binding"
    | "by"
    | "calc"
    | "case"
    | "class"
    | "classifier"
    | "comment"
    | "composite"
    | "concern"
    | "conjugate"
    | "connect"
    | "connection"
    | "connector"
    | "constraint"
    | "datatype"
    | "def"
    | "default"
    | "dependency"
    | "derived"
    | "disjoint"
    | "do"
    | "doc"
    | "else"
    | "end"
    | "entry"
    | "enum"
    | "exit"
    | "expose"
    | "false"
    | "feature"
    | "featuring"
    | "filter"
    | "first"
    | "flow"
    | "for"
    | "frame"
    | "from"
    | "function"
    | "hastype"
    | "if"
    | "implies"
    | "import"
    | "in"
    | "include"
    | "inout"
    | "interaction"
    | "interface"
    | "istype"
    | "item"
    | "language"
    | "library"
    | "lifecycle"
    | "meta"
    | "metadata"
    | "not"
    | "null"
    | "objective"
    | "occurrence"
    | "of"
    | "or"
    | "out"
    | "package"
    | "parallel"
    | "part"
    | "perform"
    | "port"
    | "portion"
    | "predicate"
    | "private"
    | "protected"
    | "public"
    | "readonly"
    | "redefines"
    | "redefinition"
    | "ref"
    | "references"
    | "rendering"
    | "rep"
    | "require"
    | "requirement"
    | "return"
    | "send"
    | "specialization"
    | "specializes"
    | "stakeholder"
    | "standard"
    | "state"
    | "struct"
    | "subclassification"
    | "subclassifier"
    | "subject"
    | "subset"
    | "subsets"
    | "subtype"
    | "succession"
    | "then"
    | "to"
    | "transition"
    | "true"
    | "type"
    | "typed"
    | "until"
    | "use"
    | "variant"
    | "verification"
    | "via"
    | "view"
    | "viewpoint"
    | "while"
    | "xor"
    | "{"
    | "|"
    | "}"
    | "~";

export type SysMLTokenNames = SysMLTerminalNames | SysMLKeywordNames;

export type ActionBodyElement = AcceptAction | ActionUsage | AssertConstraint | AssignmentAction | ForLoopAction | IfThenAction | NamespaceElement | PerformAction | SendAction | SuccessionUsage | WhileLoopAction;

export const ActionBodyElement = 'ActionBodyElement';

export function isActionBodyElement(item: unknown): item is ActionBodyElement {
    return reflection.isInstance(item, ActionBodyElement);
}

export type AdditiveOperator = '+' | '-';

export function isAdditiveOperator(item: unknown): item is AdditiveOperator {
    return item === '+' || item === '-';
}

export type CalculationBodyElement = ActionUsage | AttributeUsage | NamespaceElement | ReturnUsage;

export const CalculationBodyElement = 'CalculationBodyElement';

export function isCalculationBodyElement(item: unknown): item is CalculationBodyElement {
    return reflection.isInstance(item, CalculationBodyElement);
}

export type CaseBodyElement = ActionUsage | ActorMember | NamespaceElement | ObjectiveMember | SubjectUsage;

export const CaseBodyElement = 'CaseBodyElement';

export function isCaseBodyElement(item: unknown): item is CaseBodyElement {
    return reflection.isInstance(item, CaseBodyElement);
}

export type ClassificationOperator = '@' | 'as' | 'hastype' | 'istype' | 'meta';

export function isClassificationOperator(item: unknown): item is ClassificationOperator {
    return item === 'hastype' || item === 'istype' || item === '@' || item === 'as' || item === 'meta';
}

export type ConstraintBodyElement = AttributeUsage | NamespaceElement;

export const ConstraintBodyElement = 'ConstraintBodyElement';

export function isConstraintBodyElement(item: unknown): item is ConstraintBodyElement {
    return reflection.isInstance(item, ConstraintBodyElement);
}

export type Element = ActionDefinition | ActionUsage | Allocate | AllocationDefinition | AllocationUsage | AnalysisCaseDefinition | AnalysisCaseUsage | Association | AttributeDefinition | AttributeUsage | Behavior | BindingConnector | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | Classifier | Comment | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectionUsage | Connector | ConstraintDefinition | ConstraintUsage | DataType | Dependency | Documentation | EnumerationDefinition | EnumerationUsage | Feature | FeatureTypingDecl | FlowConnectionDefinition | FlowConnectionUsage | FunctionDecl | Interaction | InterfaceDefinition | InterfaceUsage | ItemDefinition | ItemFlow | ItemUsage | LibraryPackage | MetadataDefinition | MetadataUsage | OccurrenceDefinition | OccurrenceUsage | Package | PartDefinition | PartUsage | PortDefinition | PortUsage | Predicate | Redefinition | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | Specialization | StateDefinition | StateUsage | Struct | Subclassification | Subsetting | Succession | TextualRepresentation | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;

export const Element = 'Element';

export function isElement(item: unknown): item is Element {
    return reflection.isInstance(item, Element);
}

export type EqualityOperator = '!=' | '!==' | '==' | '===';

export function isEqualityOperator(item: unknown): item is EqualityOperator {
    return item === '==' || item === '!=' || item === '===' || item === '!==';
}

export type FeatureBodyElement = FeatureMember | NamespaceElement | RelationshipElement;

export const FeatureBodyElement = 'FeatureBodyElement';

export function isFeatureBodyElement(item: unknown): item is FeatureBodyElement {
    return reflection.isInstance(item, FeatureBodyElement);
}

export type FeatureDirectionKind = 'in' | 'inout' | 'out';

export function isFeatureDirectionKind(item: unknown): item is FeatureDirectionKind {
    return item === 'in' || item === 'out' || item === 'inout';
}

export type LiteralExpression = LiteralBoolean | LiteralDefault | LiteralInteger | LiteralNull | LiteralReal | LiteralString;

export const LiteralExpression = 'LiteralExpression';

export function isLiteralExpression(item: unknown): item is LiteralExpression {
    return reflection.isInstance(item, LiteralExpression);
}

export type LiteralValue = LiteralBoolean | LiteralDefault | LiteralInteger | LiteralNull | LiteralReal | LiteralString;

export const LiteralValue = 'LiteralValue';

export function isLiteralValue(item: unknown): item is LiteralValue {
    return reflection.isInstance(item, LiteralValue);
}

export type MultiplicativeOperator = '%' | '*' | '/';

export function isMultiplicativeOperator(item: unknown): item is MultiplicativeOperator {
    return item === '*' || item === '/' || item === '%';
}

export type MultiplicityBoundValue = '*' | string;

export function isMultiplicityBoundValue(item: unknown): item is MultiplicityBoundValue {
    return item === '*' || (typeof item === 'string' && (/0[xX][0-9a-fA-F]+|0[bB][01]+|0[oO][0-7]+|[0-9]+/.test(item)));
}

export type Name = string;

export function isName(item: unknown): item is Name {
    return (typeof item === 'string' && (/[a-zA-Z_][a-zA-Z0-9_]*/.test(item) || /'([^'\\]|\\.)*'/.test(item)));
}

export type NamePart = string;

export function isNamePart(item: unknown): item is NamePart {
    return (typeof item === 'string' && (/[a-zA-Z_][a-zA-Z0-9_]*/.test(item) || /'([^'\\]|\\.)*'/.test(item)));
}

export type NamespaceElement = AliasMember | Import | OwningMembership;

export const NamespaceElement = 'NamespaceElement';

export function isNamespaceElement(item: unknown): item is NamespaceElement {
    return reflection.isInstance(item, NamespaceElement);
}

export type OwnedExpression = AdditiveExpression | AndExpression | BodyExpression | ClassificationExpression | ConditionalExpression | EqualityExpression | ExponentiationExpression | ExtentExpression | FeatureChainExpression | FeatureReferenceExpression | ImpliesExpression | InvocationExpression | LiteralExpression | MultiplicativeExpression | NullCoalescingExpression | OrExpression | RangeExpression | RelationalExpression | UnaryExpression | XorExpression;

export const OwnedExpression = 'OwnedExpression';

export function isOwnedExpression(item: unknown): item is OwnedExpression {
    return reflection.isInstance(item, OwnedExpression);
}

export type RelationalOperator = '<' | '<=' | '>' | '>=';

export function isRelationalOperator(item: unknown): item is RelationalOperator {
    return item === '<' || item === '>' || item === '<=' || item === '>=';
}

export type RelationshipElement = FeatureTypingDecl | Redefinition | Specialization | Subclassification | Subsetting;

export const RelationshipElement = 'RelationshipElement';

export function isRelationshipElement(item: unknown): item is RelationshipElement {
    return reflection.isInstance(item, RelationshipElement);
}

export type RequirementBodyElement = ActorMember | AssumeConstraint | ConstraintUsage | Documentation | FramedConcern | NamespaceElement | ObjectiveMember | RequireConstraint | RequirementUsage | StakeholderMember | SubjectUsage;

export const RequirementBodyElement = 'RequirementBodyElement';

export function isRequirementBodyElement(item: unknown): item is RequirementBodyElement {
    return reflection.isInstance(item, RequirementBodyElement);
}

export type StateBodyElement = DoAction | EntryAction | ExitAction | NamespaceElement | StateUsage | TransitionUsage;

export const StateBodyElement = 'StateBodyElement';

export function isStateBodyElement(item: unknown): item is StateBodyElement {
    return reflection.isInstance(item, StateBodyElement);
}

export type TypeBodyElement = FeatureMember | NamespaceElement | RelationshipElement;

export const TypeBodyElement = 'TypeBodyElement';

export function isTypeBodyElement(item: unknown): item is TypeBodyElement {
    return reflection.isInstance(item, TypeBodyElement);
}

export type UnaryOperator = '!' | '+' | '-' | 'not' | '~';

export function isUnaryOperator(item: unknown): item is UnaryOperator {
    return item === '+' || item === '-' || item === '!' || item === '~' || item === 'not';
}

export type UseCaseBodyElement = ActionUsage | ActorMember | IncludeUseCaseUsage | NamespaceElement | ObjectiveMember | SubjectUsage;

export const UseCaseBodyElement = 'UseCaseBodyElement';

export function isUseCaseBodyElement(item: unknown): item is UseCaseBodyElement {
    return reflection.isInstance(item, UseCaseBodyElement);
}

export type ViewBodyElement = ExposeElement | FilterElement | NamespaceElement | RenderingUsage | ViewUsage;

export const ViewBodyElement = 'ViewBodyElement';

export function isViewBodyElement(item: unknown): item is ViewBodyElement {
    return reflection.isInstance(item, ViewBodyElement);
}

export type VisibilityIndicator = 'private' | 'protected' | 'public';

export function isVisibilityIndicator(item: unknown): item is VisibilityIndicator {
    return item === 'public' || item === 'private' || item === 'protected';
}

export interface AcceptAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AcceptAction';
    acceptName?: Name;
    acceptTypes: Array<QualifiedName>;
    via?: QualifiedName;
}

export const AcceptAction = 'AcceptAction';

export function isAcceptAction(item: unknown): item is AcceptAction {
    return reflection.isInstance(item, AcceptAction);
}

export interface ActionDefinition extends langium.AstNode {
    readonly $type: 'ActionBodyRule' | 'ActionDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ActionDefinition = 'ActionDefinition';

export function isActionDefinition(item: unknown): item is ActionDefinition {
    return reflection.isInstance(item, ActionDefinition);
}

export interface ActionUsage extends langium.AstNode {
    readonly $type: 'ActionBodyRule' | 'ActionUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ActionUsage = 'ActionUsage';

export function isActionUsage(item: unknown): item is ActionUsage {
    return reflection.isInstance(item, ActionUsage);
}

export interface ActorMember extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'ActorMember';
    actor?: PartUsage;
    inlineActor?: InlinePartDecl;
}

export const ActorMember = 'ActorMember';

export function isActorMember(item: unknown): item is ActorMember {
    return reflection.isInstance(item, ActorMember);
}

export interface AdditiveExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'AdditiveExpression';
    left: OwnedExpression;
    operator: AdditiveOperator;
    right: OwnedExpression;
}

export const AdditiveExpression = 'AdditiveExpression';

export function isAdditiveExpression(item: unknown): item is AdditiveExpression {
    return reflection.isInstance(item, AdditiveExpression);
}

export interface AliasMember extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'AliasMember';
    aliasName: Name;
    target: QualifiedName;
    visibility?: VisibilityIndicator;
}

export const AliasMember = 'AliasMember';

export function isAliasMember(item: unknown): item is AliasMember {
    return reflection.isInstance(item, AliasMember);
}

export interface Allocate extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Allocate';
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}

export const Allocate = 'Allocate';

export function isAllocate(item: unknown): item is Allocate {
    return reflection.isInstance(item, Allocate);
}

export interface AllocationDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'AllocationDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const AllocationDefinition = 'AllocationDefinition';

export function isAllocationDefinition(item: unknown): item is AllocationDefinition {
    return reflection.isInstance(item, AllocationDefinition);
}

export interface AllocationUsage extends langium.AstNode {
    readonly $type: 'AllocationUsage' | 'AllocationUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const AllocationUsage = 'AllocationUsage';

export function isAllocationUsage(item: unknown): item is AllocationUsage {
    return reflection.isInstance(item, AllocationUsage);
}

export interface AnalysisCaseDefinition extends langium.AstNode {
    readonly $type: 'AnalysisCaseDefinition' | 'CaseBodyRule' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const AnalysisCaseDefinition = 'AnalysisCaseDefinition';

export function isAnalysisCaseDefinition(item: unknown): item is AnalysisCaseDefinition {
    return reflection.isInstance(item, AnalysisCaseDefinition);
}

export interface AnalysisCaseUsage extends langium.AstNode {
    readonly $type: 'AnalysisCaseUsage' | 'CaseBodyRule' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const AnalysisCaseUsage = 'AnalysisCaseUsage';

export function isAnalysisCaseUsage(item: unknown): item is AnalysisCaseUsage {
    return reflection.isInstance(item, AnalysisCaseUsage);
}

export interface AndExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'AndExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const AndExpression = 'AndExpression';

export function isAndExpression(item: unknown): item is AndExpression {
    return reflection.isInstance(item, AndExpression);
}

export interface AssertConstraint extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AssertConstraint';
    asserted: ConstraintUsage;
    isNegated: boolean;
}

export const AssertConstraint = 'AssertConstraint';

export function isAssertConstraint(item: unknown): item is AssertConstraint {
    return reflection.isInstance(item, AssertConstraint);
}

export interface AssignmentAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AssignmentAction';
    target: QualifiedName;
    value: OwnedExpression;
}

export const AssignmentAction = 'AssignmentAction';

export function isAssignmentAction(item: unknown): item is AssignmentAction {
    return reflection.isInstance(item, AssignmentAction);
}

export interface Association extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Association' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isStruct: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Association = 'Association';

export function isAssociation(item: unknown): item is Association {
    return reflection.isInstance(item, Association);
}

export interface AssumeConstraint extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'AssumeConstraint';
    assumed: ConstraintUsage;
}

export const AssumeConstraint = 'AssumeConstraint';

export function isAssumeConstraint(item: unknown): item is AssumeConstraint {
    return reflection.isInstance(item, AssumeConstraint);
}

export interface AttributeDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'AttributeDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const AttributeDefinition = 'AttributeDefinition';

export function isAttributeDefinition(item: unknown): item is AttributeDefinition {
    return reflection.isInstance(item, AttributeDefinition);
}

export interface AttributeUsage extends langium.AstNode {
    readonly $container: CalculationBodyRule | ConstraintBodyRule | OwningMembership;
    readonly $type: 'AttributeUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const AttributeUsage = 'AttributeUsage';

export function isAttributeUsage(item: unknown): item is AttributeUsage {
    return reflection.isInstance(item, AttributeUsage);
}

export interface Behavior extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Behavior' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Behavior = 'Behavior';

export function isBehavior(item: unknown): item is Behavior {
    return reflection.isInstance(item, Behavior);
}

export interface BindingConnector extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'BindingConnector';
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
    visibility?: VisibilityIndicator;
}

export const BindingConnector = 'BindingConnector';

export function isBindingConnector(item: unknown): item is BindingConnector {
    return reflection.isInstance(item, BindingConnector);
}

export interface BodyExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'BodyExpression';
    statements: Array<OwnedExpression>;
}

export const BodyExpression = 'BodyExpression';

export function isBodyExpression(item: unknown): item is BodyExpression {
    return reflection.isInstance(item, BodyExpression);
}

export interface CalculationDefinition extends langium.AstNode {
    readonly $type: 'CalculationBodyRule' | 'CalculationDefinition' | 'ParameterListPart' | 'ReturnTypePart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const CalculationDefinition = 'CalculationDefinition';

export function isCalculationDefinition(item: unknown): item is CalculationDefinition {
    return reflection.isInstance(item, CalculationDefinition);
}

export interface CalculationUsage extends langium.AstNode {
    readonly $type: 'CalculationBodyRule' | 'CalculationUsage' | 'ParameterListPart' | 'ReturnTypePart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const CalculationUsage = 'CalculationUsage';

export function isCalculationUsage(item: unknown): item is CalculationUsage {
    return reflection.isInstance(item, CalculationUsage);
}

export interface CaseDefinition extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'CaseDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const CaseDefinition = 'CaseDefinition';

export function isCaseDefinition(item: unknown): item is CaseDefinition {
    return reflection.isInstance(item, CaseDefinition);
}

export interface CaseUsage extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'CaseUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const CaseUsage = 'CaseUsage';

export function isCaseUsage(item: unknown): item is CaseUsage {
    return reflection.isInstance(item, CaseUsage);
}

export interface Class extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Class' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Class = 'Class';

export function isClass(item: unknown): item is Class {
    return reflection.isInstance(item, Class);
}

export interface ClassificationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ClassificationExpression';
    classType: QualifiedName;
    operand: OwnedExpression;
    operator: ClassificationOperator;
}

export const ClassificationExpression = 'ClassificationExpression';

export function isClassificationExpression(item: unknown): item is ClassificationExpression {
    return reflection.isInstance(item, ClassificationExpression);
}

export interface Classifier extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Classifier' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Classifier = 'Classifier';

export function isClassifier(item: unknown): item is Classifier {
    return reflection.isInstance(item, Classifier);
}

export interface Comment extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Comment';
    about: Array<QualifiedName>;
    body: string;
    language?: string;
    name?: Name;
}

export const Comment = 'Comment';

export function isComment(item: unknown): item is Comment {
    return reflection.isInstance(item, Comment);
}

export interface ConcernDefinition extends langium.AstNode {
    readonly $type: 'ConcernDefinition' | 'ParameterListPart' | 'RequirementBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ConcernDefinition = 'ConcernDefinition';

export function isConcernDefinition(item: unknown): item is ConcernDefinition {
    return reflection.isInstance(item, ConcernDefinition);
}

export interface ConcernUsage extends langium.AstNode {
    readonly $type: 'ConcernUsage' | 'RequirementBodyRule';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ConcernUsage = 'ConcernUsage';

export function isConcernUsage(item: unknown): item is ConcernUsage {
    return reflection.isInstance(item, ConcernUsage);
}

export interface ConditionalExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ConditionalExpression';
    condition: OwnedExpression;
    elseExpr: OwnedExpression;
    thenExpr: OwnedExpression;
}

export const ConditionalExpression = 'ConditionalExpression';

export function isConditionalExpression(item: unknown): item is ConditionalExpression {
    return reflection.isInstance(item, ConditionalExpression);
}

export interface ConnectionDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ConnectionDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ConnectionDefinition = 'ConnectionDefinition';

export function isConnectionDefinition(item: unknown): item is ConnectionDefinition {
    return reflection.isInstance(item, ConnectionDefinition);
}

export interface ConnectionUsage extends langium.AstNode {
    readonly $type: 'ConnectionUsage' | 'ConnectionUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const ConnectionUsage = 'ConnectionUsage';

export function isConnectionUsage(item: unknown): item is ConnectionUsage {
    return reflection.isInstance(item, ConnectionUsage);
}

export interface Connector extends langium.AstNode {
    readonly $type: 'Connector' | 'ConnectorDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const Connector = 'Connector';

export function isConnector(item: unknown): item is Connector {
    return reflection.isInstance(item, Connector);
}

export interface ConnectorEnd extends langium.AstNode {
    readonly $container: Allocate | AllocationUsageDecl | BindingConnector | ConnectionUsageDecl | ConnectorDecl | FlowConnectionUsageDecl | InterfaceUsageDecl | ItemFlowDecl | SuccessionDecl | SuccessionUsage;
    readonly $type: 'ConnectorEnd';
    endName?: Name;
    multiplicity?: MultiplicityBounds;
    target: FeatureChainRef;
}

export const ConnectorEnd = 'ConnectorEnd';

export function isConnectorEnd(item: unknown): item is ConnectorEnd {
    return reflection.isInstance(item, ConnectorEnd);
}

export interface ConstraintDefinition extends langium.AstNode {
    readonly $type: 'ConstraintBodyRule' | 'ConstraintDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ConstraintDefinition = 'ConstraintDefinition';

export function isConstraintDefinition(item: unknown): item is ConstraintDefinition {
    return reflection.isInstance(item, ConstraintDefinition);
}

export interface ConstraintUsage extends langium.AstNode {
    readonly $type: 'ConstraintBodyRule' | 'ConstraintUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ConstraintUsage = 'ConstraintUsage';

export function isConstraintUsage(item: unknown): item is ConstraintUsage {
    return reflection.isInstance(item, ConstraintUsage);
}

export interface DataType extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'DataType' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const DataType = 'DataType';

export function isDataType(item: unknown): item is DataType {
    return reflection.isInstance(item, DataType);
}

export interface Dependency extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Dependency';
    clients: Array<QualifiedName>;
    name?: Name;
    suppliers: Array<QualifiedName>;
}

export const Dependency = 'Dependency';

export function isDependency(item: unknown): item is Dependency {
    return reflection.isInstance(item, Dependency);
}

export interface DoAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'DoAction';
    action: ActionUsage;
}

export const DoAction = 'DoAction';

export function isDoAction(item: unknown): item is DoAction {
    return reflection.isInstance(item, DoAction);
}

export interface Documentation extends langium.AstNode {
    readonly $container: OwningMembership | RequirementBodyRule;
    readonly $type: 'Documentation';
    about: Array<QualifiedName>;
    body: string;
    language?: string;
    name?: Name;
}

export const Documentation = 'Documentation';

export function isDocumentation(item: unknown): item is Documentation {
    return reflection.isInstance(item, Documentation);
}

export interface EffectActionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'EffectActionPart';
    effectAction?: InlineAction;
    effectBody?: ActionBodyRule;
}

export const EffectActionPart = 'EffectActionPart';

export function isEffectActionPart(item: unknown): item is EffectActionPart {
    return reflection.isInstance(item, EffectActionPart);
}

export interface EntryAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'EntryAction';
    action: ActionUsage;
}

export const EntryAction = 'EntryAction';

export function isEntryAction(item: unknown): item is EntryAction {
    return reflection.isInstance(item, EntryAction);
}

export interface EnumerationDefinition extends langium.AstNode {
    readonly $type: 'EnumerationBodyRule' | 'EnumerationDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const EnumerationDefinition = 'EnumerationDefinition';

export function isEnumerationDefinition(item: unknown): item is EnumerationDefinition {
    return reflection.isInstance(item, EnumerationDefinition);
}

export interface EnumerationUsage extends langium.AstNode {
    readonly $container: EnumerationBodyRule | OwningMembership;
    readonly $type: 'EnumerationUsage';
    enumType?: QualifiedName;
    name?: Name;
}

export const EnumerationUsage = 'EnumerationUsage';

export function isEnumerationUsage(item: unknown): item is EnumerationUsage {
    return reflection.isInstance(item, EnumerationUsage);
}

export interface EqualityExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'EqualityExpression';
    left: OwnedExpression;
    operator: EqualityOperator;
    right: OwnedExpression;
}

export const EqualityExpression = 'EqualityExpression';

export function isEqualityExpression(item: unknown): item is EqualityExpression {
    return reflection.isInstance(item, EqualityExpression);
}

export interface ExitAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'ExitAction';
    action: ActionUsage;
}

export const ExitAction = 'ExitAction';

export function isExitAction(item: unknown): item is ExitAction {
    return reflection.isInstance(item, ExitAction);
}

export interface ExponentiationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ExponentiationExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const ExponentiationExpression = 'ExponentiationExpression';

export function isExponentiationExpression(item: unknown): item is ExponentiationExpression {
    return reflection.isInstance(item, ExponentiationExpression);
}

export interface ExposeElement extends langium.AstNode {
    readonly $container: ViewBodyRule;
    readonly $type: 'ExposeElement';
    exposed: QualifiedName;
}

export const ExposeElement = 'ExposeElement';

export function isExposeElement(item: unknown): item is ExposeElement {
    return reflection.isInstance(item, ExposeElement);
}

export interface ExtentExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ExtentExpression';
    extentType: QualifiedName;
}

export const ExtentExpression = 'ExtentExpression';

export function isExtentExpression(item: unknown): item is ExtentExpression {
    return reflection.isInstance(item, ExtentExpression);
}

export interface Feature extends langium.AstNode {
    readonly $container: FeatureMember | OwningMembership;
    readonly $type: 'Feature';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const Feature = 'Feature';

export function isFeature(item: unknown): item is Feature {
    return reflection.isInstance(item, Feature);
}

export interface FeatureBodyRule extends langium.AstNode {
    readonly $container: AllocationUsage | AttributeUsage | ConnectionUsage | Connector | Feature | FlowConnectionUsage | InterfaceUsage | ItemFlow | ItemUsage | OccurrenceUsage | PartUsage | PortUsage | SubjectUsage | Succession;
    readonly $type: 'FeatureBodyRule';
    elements: Array<FeatureBodyElement>;
}

export const FeatureBodyRule = 'FeatureBodyRule';

export function isFeatureBodyRule(item: unknown): item is FeatureBodyRule {
    return reflection.isInstance(item, FeatureBodyRule);
}

export interface FeatureChainExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'FeatureChainExpression';
    members: Array<FeatureReferenceMember>;
    source: OwnedExpression;
}

export const FeatureChainExpression = 'FeatureChainExpression';

export function isFeatureChainExpression(item: unknown): item is FeatureChainExpression {
    return reflection.isInstance(item, FeatureChainExpression);
}

export interface FeatureChainRef extends langium.AstNode {
    readonly $container: ConnectorEnd;
    readonly $type: 'FeatureChainRef';
    names: Array<NamePart>;
}

export const FeatureChainRef = 'FeatureChainRef';

export function isFeatureChainRef(item: unknown): item is FeatureChainRef {
    return reflection.isInstance(item, FeatureChainRef);
}

export interface FeatureMember extends langium.AstNode {
    readonly $container: FeatureBodyRule | TypeBodyRule;
    readonly $type: 'FeatureMember';
    feature: Feature;
    visibility?: VisibilityIndicator;
}

export const FeatureMember = 'FeatureMember';

export function isFeatureMember(item: unknown): item is FeatureMember {
    return reflection.isInstance(item, FeatureMember);
}

export interface FeatureReferenceExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'FeatureReferenceExpression';
    referent: QualifiedName;
}

export const FeatureReferenceExpression = 'FeatureReferenceExpression';

export function isFeatureReferenceExpression(item: unknown): item is FeatureReferenceExpression {
    return reflection.isInstance(item, FeatureReferenceExpression);
}

export interface FeatureReferenceMember extends langium.AstNode {
    readonly $container: FeatureChainExpression;
    readonly $type: 'FeatureReferenceMember';
    arguments: Array<OwnedExpression>;
    featureRef: QualifiedName;
}

export const FeatureReferenceMember = 'FeatureReferenceMember';

export function isFeatureReferenceMember(item: unknown): item is FeatureReferenceMember {
    return reflection.isInstance(item, FeatureReferenceMember);
}

export interface FeatureTypeRef extends langium.AstNode {
    readonly $container: ActionUsage | AnalysisCaseUsage | AttributeUsage | CalculationUsage | CaseUsage | ConcernUsage | ConstraintUsage | Feature | ItemUsage | OccurrenceUsage | PartUsage | PortUsage | RenderingUsage | RequirementUsage | StateUsage | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage;
    readonly $type: 'FeatureTypeRef';
    isDefault: boolean;
    type: QualifiedName;
}

export const FeatureTypeRef = 'FeatureTypeRef';

export function isFeatureTypeRef(item: unknown): item is FeatureTypeRef {
    return reflection.isInstance(item, FeatureTypeRef);
}

export interface FeatureTypingDecl extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | TypeBodyRule;
    readonly $type: 'FeatureTypingDecl';
    featureType: QualifiedName;
    name?: Name;
    typedFeature: QualifiedName;
}

export const FeatureTypingDecl = 'FeatureTypingDecl';

export function isFeatureTypingDecl(item: unknown): item is FeatureTypingDecl {
    return reflection.isInstance(item, FeatureTypingDecl);
}

export interface FilterElement extends langium.AstNode {
    readonly $container: ViewBodyRule;
    readonly $type: 'FilterElement';
    filterExpr: OwnedExpression;
}

export const FilterElement = 'FilterElement';

export function isFilterElement(item: unknown): item is FilterElement {
    return reflection.isInstance(item, FilterElement);
}

export interface FlowConnectionDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'FlowConnectionDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const FlowConnectionDefinition = 'FlowConnectionDefinition';

export function isFlowConnectionDefinition(item: unknown): item is FlowConnectionDefinition {
    return reflection.isInstance(item, FlowConnectionDefinition);
}

export interface FlowConnectionUsage extends langium.AstNode {
    readonly $type: 'FlowConnectionUsage' | 'FlowConnectionUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const FlowConnectionUsage = 'FlowConnectionUsage';

export function isFlowConnectionUsage(item: unknown): item is FlowConnectionUsage {
    return reflection.isInstance(item, FlowConnectionUsage);
}

export interface ForLoopAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'ForLoopAction';
    body: ActionBodyRule;
    loopVariable: Name;
    loopVariableType?: QualifiedName;
    sequence: OwnedExpression;
}

export const ForLoopAction = 'ForLoopAction';

export function isForLoopAction(item: unknown): item is ForLoopAction {
    return reflection.isInstance(item, ForLoopAction);
}

export interface FramedConcern extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'FramedConcern';
    framedConcern: ConcernUsage;
}

export const FramedConcern = 'FramedConcern';

export function isFramedConcern(item: unknown): item is FramedConcern {
    return reflection.isInstance(item, FramedConcern);
}

export interface FunctionDecl extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'FunctionDecl' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const FunctionDecl = 'FunctionDecl';

export function isFunctionDecl(item: unknown): item is FunctionDecl {
    return reflection.isInstance(item, FunctionDecl);
}

export interface GuardExpressionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'GuardExpressionPart';
    guardExpr: OwnedExpression;
}

export const GuardExpressionPart = 'GuardExpressionPart';

export function isGuardExpressionPart(item: unknown): item is GuardExpressionPart {
    return reflection.isInstance(item, GuardExpressionPart);
}

export interface IfThenAction extends langium.AstNode {
    readonly $container: ActionBodyRule | IfThenAction;
    readonly $type: 'IfThenAction';
    condition: OwnedExpression;
    elseBody?: ActionBodyRule;
    elseIf?: IfThenAction;
    thenBody: ActionBodyRule;
}

export const IfThenAction = 'IfThenAction';

export function isIfThenAction(item: unknown): item is IfThenAction {
    return reflection.isInstance(item, IfThenAction);
}

export interface ImpliesExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ImpliesExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const ImpliesExpression = 'ImpliesExpression';

export function isImpliesExpression(item: unknown): item is ImpliesExpression {
    return reflection.isInstance(item, ImpliesExpression);
}

export interface Import extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'Import';
    importRef: ImportReference;
    isAll: boolean;
    visibility?: VisibilityIndicator;
}

export const Import = 'Import';

export function isImport(item: unknown): item is Import {
    return reflection.isInstance(item, Import);
}

export interface ImportReference extends langium.AstNode {
    readonly $container: Import;
    readonly $type: 'ImportReference';
    isRecursive: boolean;
    isWildcard: boolean;
    names: Array<NamePart>;
}

export const ImportReference = 'ImportReference';

export function isImportReference(item: unknown): item is ImportReference {
    return reflection.isInstance(item, ImportReference);
}

export interface IncludeUseCaseUsage extends langium.AstNode {
    readonly $container: UseCaseBodyRule;
    readonly $type: 'IncludeUseCaseUsage';
    included: UseCaseUsage;
}

export const IncludeUseCaseUsage = 'IncludeUseCaseUsage';

export function isIncludeUseCaseUsage(item: unknown): item is IncludeUseCaseUsage {
    return reflection.isInstance(item, IncludeUseCaseUsage);
}

export interface InlineAction extends langium.AstNode {
    readonly $container: EffectActionPart;
    readonly $type: 'InlineAction';
    actionName?: Name;
    actionTypes: Array<QualifiedName>;
}

export const InlineAction = 'InlineAction';

export function isInlineAction(item: unknown): item is InlineAction {
    return reflection.isInstance(item, InlineAction);
}

export interface InlinePartDecl extends langium.AstNode {
    readonly $container: ActorMember | StakeholderMember;
    readonly $type: 'InlinePartDecl';
    name?: Name;
    types: Array<QualifiedName>;
}

export const InlinePartDecl = 'InlinePartDecl';

export function isInlinePartDecl(item: unknown): item is InlinePartDecl {
    return reflection.isInstance(item, InlinePartDecl);
}

export interface Interaction extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Interaction' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Interaction = 'Interaction';

export function isInteraction(item: unknown): item is Interaction {
    return reflection.isInstance(item, Interaction);
}

export interface InterfaceDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'InterfaceDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const InterfaceDefinition = 'InterfaceDefinition';

export function isInterfaceDefinition(item: unknown): item is InterfaceDefinition {
    return reflection.isInstance(item, InterfaceDefinition);
}

export interface InterfaceUsage extends langium.AstNode {
    readonly $type: 'InterfaceUsage' | 'InterfaceUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const InterfaceUsage = 'InterfaceUsage';

export function isInterfaceUsage(item: unknown): item is InterfaceUsage {
    return reflection.isInstance(item, InterfaceUsage);
}

export interface InvocationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'InvocationExpression';
    arguments: Array<OwnedExpression>;
    invoked: QualifiedName;
}

export const InvocationExpression = 'InvocationExpression';

export function isInvocationExpression(item: unknown): item is InvocationExpression {
    return reflection.isInstance(item, InvocationExpression);
}

export interface ItemDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ItemDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ItemDefinition = 'ItemDefinition';

export function isItemDefinition(item: unknown): item is ItemDefinition {
    return reflection.isInstance(item, ItemDefinition);
}

export interface ItemFlow extends langium.AstNode {
    readonly $type: 'ItemFlow' | 'ItemFlowDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const ItemFlow = 'ItemFlow';

export function isItemFlow(item: unknown): item is ItemFlow {
    return reflection.isInstance(item, ItemFlow);
}

export interface ItemUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ItemUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ItemUsage = 'ItemUsage';

export function isItemUsage(item: unknown): item is ItemUsage {
    return reflection.isInstance(item, ItemUsage);
}

export interface LibraryPackage extends langium.AstNode {
    readonly $type: 'LibraryPackage' | 'PackageBody';
    isStandard: boolean;
    name?: Name;
}

export const LibraryPackage = 'LibraryPackage';

export function isLibraryPackage(item: unknown): item is LibraryPackage {
    return reflection.isInstance(item, LibraryPackage);
}

export interface LiteralBoolean extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralBoolean';
    value: boolean;
}

export const LiteralBoolean = 'LiteralBoolean';

export function isLiteralBoolean(item: unknown): item is LiteralBoolean {
    return reflection.isInstance(item, LiteralBoolean);
}

export interface LiteralDefault extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralDefault';
}

export const LiteralDefault = 'LiteralDefault';

export function isLiteralDefault(item: unknown): item is LiteralDefault {
    return reflection.isInstance(item, LiteralDefault);
}

export interface LiteralInteger extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralInteger';
    value: string;
}

export const LiteralInteger = 'LiteralInteger';

export function isLiteralInteger(item: unknown): item is LiteralInteger {
    return reflection.isInstance(item, LiteralInteger);
}

export interface LiteralNull extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralNull';
}

export const LiteralNull = 'LiteralNull';

export function isLiteralNull(item: unknown): item is LiteralNull {
    return reflection.isInstance(item, LiteralNull);
}

export interface LiteralReal extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralReal';
    value: string;
}

export const LiteralReal = 'LiteralReal';

export function isLiteralReal(item: unknown): item is LiteralReal {
    return reflection.isInstance(item, LiteralReal);
}

export interface LiteralString extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralString';
    value: string;
}

export const LiteralString = 'LiteralString';

export function isLiteralString(item: unknown): item is LiteralString {
    return reflection.isInstance(item, LiteralString);
}

export interface MetadataBodyElement extends langium.AstNode {
    readonly $container: MetadataBodyOpt | MetadataUsage;
    readonly $type: 'MetadataBodyElement';
    featureName: Name;
    featureType?: QualifiedName;
    featureValue: MetadataValue;
}

export const MetadataBodyElement = 'MetadataBodyElement';

export function isMetadataBodyElement(item: unknown): item is MetadataBodyElement {
    return reflection.isInstance(item, MetadataBodyElement);
}

export interface MetadataBodyOpt extends langium.AstNode {
    readonly $type: 'MetadataBodyOpt';
    elements: Array<MetadataBodyElement>;
}

export const MetadataBodyOpt = 'MetadataBodyOpt';

export function isMetadataBodyOpt(item: unknown): item is MetadataBodyOpt {
    return reflection.isInstance(item, MetadataBodyOpt);
}

export interface MetadataDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'MetadataDefinition' | 'TypeBodyRule';
    about: Array<QualifiedName>;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const MetadataDefinition = 'MetadataDefinition';

export function isMetadataDefinition(item: unknown): item is MetadataDefinition {
    return reflection.isInstance(item, MetadataDefinition);
}

export interface MetadataUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'MetadataUsage';
    atElements: Array<MetadataBodyElement>;
    metadataElements: Array<MetadataBodyElement>;
    metaTypes: Array<QualifiedName>;
    name?: Name;
    type?: QualifiedName;
}

export const MetadataUsage = 'MetadataUsage';

export function isMetadataUsage(item: unknown): item is MetadataUsage {
    return reflection.isInstance(item, MetadataUsage);
}

export interface MetadataValue extends langium.AstNode {
    readonly $container: MetadataBodyElement | MetadataValue;
    readonly $type: 'LiteralBoolean' | 'LiteralDefault' | 'LiteralInteger' | 'LiteralNull' | 'LiteralReal' | 'LiteralString' | 'LiteralValue' | 'MetadataValue';
    valueRef?: QualifiedName;
    values: Array<MetadataValue>;
}

export const MetadataValue = 'MetadataValue';

export function isMetadataValue(item: unknown): item is MetadataValue {
    return reflection.isInstance(item, MetadataValue);
}

export interface MultiplicativeExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'MultiplicativeExpression';
    left: OwnedExpression;
    operator: MultiplicativeOperator;
    right: OwnedExpression;
}

export const MultiplicativeExpression = 'MultiplicativeExpression';

export function isMultiplicativeExpression(item: unknown): item is MultiplicativeExpression {
    return reflection.isInstance(item, MultiplicativeExpression);
}

export interface MultiplicityBounds extends langium.AstNode {
    readonly $container: ActionDefinition | ActionUsage | AllocationDefinition | AnalysisCaseDefinition | AnalysisCaseUsage | Association | AttributeDefinition | AttributeUsage | Behavior | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | Classifier | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectorEnd | ConstraintDefinition | ConstraintUsage | DataType | EnumerationDefinition | Feature | FlowConnectionDefinition | FunctionDecl | Interaction | InterfaceDefinition | ItemDefinition | ItemUsage | MetadataDefinition | OccurrenceDefinition | OccurrenceUsage | ParameterMember | PartDefinition | PartUsage | PortDefinition | PortUsage | Predicate | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | StateDefinition | StateUsage | Struct | SubjectUsage | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;
    readonly $type: 'MultiplicityBounds';
    lowerBound?: MultiplicityBoundValue;
    upperBound: MultiplicityBoundValue;
}

export const MultiplicityBounds = 'MultiplicityBounds';

export function isMultiplicityBounds(item: unknown): item is MultiplicityBounds {
    return reflection.isInstance(item, MultiplicityBounds);
}

export interface NullCoalescingExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'NullCoalescingExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const NullCoalescingExpression = 'NullCoalescingExpression';

export function isNullCoalescingExpression(item: unknown): item is NullCoalescingExpression {
    return reflection.isInstance(item, NullCoalescingExpression);
}

export interface ObjectiveMember extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'ObjectiveMember';
    objective: RequirementUsage;
}

export const ObjectiveMember = 'ObjectiveMember';

export function isObjectiveMember(item: unknown): item is ObjectiveMember {
    return reflection.isInstance(item, ObjectiveMember);
}

export interface OccurrenceDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'OccurrenceDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    lifecycleClass: QualifiedName;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const OccurrenceDefinition = 'OccurrenceDefinition';

export function isOccurrenceDefinition(item: unknown): item is OccurrenceDefinition {
    return reflection.isInstance(item, OccurrenceDefinition);
}

export interface OccurrenceUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'OccurrenceUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const OccurrenceUsage = 'OccurrenceUsage';

export function isOccurrenceUsage(item: unknown): item is OccurrenceUsage {
    return reflection.isInstance(item, OccurrenceUsage);
}

export interface OrExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'OrExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const OrExpression = 'OrExpression';

export function isOrExpression(item: unknown): item is OrExpression {
    return reflection.isInstance(item, OrExpression);
}

export interface OwningMembership extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'OwningMembership';
    element: Element;
    visibility?: VisibilityIndicator;
}

export const OwningMembership = 'OwningMembership';

export function isOwningMembership(item: unknown): item is OwningMembership {
    return reflection.isInstance(item, OwningMembership);
}

export interface Package extends langium.AstNode {
    readonly $type: 'Package' | 'PackageBody';
    name?: Name;
}

export const Package = 'Package';

export function isPackage(item: unknown): item is Package {
    return reflection.isInstance(item, Package);
}

export interface ParameterMember extends langium.AstNode {
    readonly $container: ParameterListPart;
    readonly $type: 'ParameterMember';
    direction?: FeatureDirectionKind;
    multiplicity?: MultiplicityBounds;
    paramName?: Name;
    paramTypes: Array<QualifiedName>;
    valueBinding: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
}

export const ParameterMember = 'ParameterMember';

export function isParameterMember(item: unknown): item is ParameterMember {
    return reflection.isInstance(item, ParameterMember);
}

export interface PartDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PartDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const PartDefinition = 'PartDefinition';

export function isPartDefinition(item: unknown): item is PartDefinition {
    return reflection.isInstance(item, PartDefinition);
}

export interface PartUsage extends langium.AstNode {
    readonly $container: ActorMember | OwningMembership | StakeholderMember;
    readonly $type: 'PartUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    isRef: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const PartUsage = 'PartUsage';

export function isPartUsage(item: unknown): item is PartUsage {
    return reflection.isInstance(item, PartUsage);
}

export interface PerformAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'PerformAction';
    performed?: ActionUsage;
    performedRef?: QualifiedName;
}

export const PerformAction = 'PerformAction';

export function isPerformAction(item: unknown): item is PerformAction {
    return reflection.isInstance(item, PerformAction);
}

export interface PortDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PortDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isConjugated: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const PortDefinition = 'PortDefinition';

export function isPortDefinition(item: unknown): item is PortDefinition {
    return reflection.isInstance(item, PortDefinition);
}

export interface PortUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PortUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isConjugated: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const PortUsage = 'PortUsage';

export function isPortUsage(item: unknown): item is PortUsage {
    return reflection.isInstance(item, PortUsage);
}

export interface Predicate extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Predicate' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Predicate = 'Predicate';

export function isPredicate(item: unknown): item is Predicate {
    return reflection.isInstance(item, Predicate);
}

export interface QualifiedName extends langium.AstNode {
    readonly $container: AcceptAction | ActionDefinition | ActionUsage | AliasMember | AllocationDefinition | AllocationUsageDecl | AnalysisCaseDefinition | AnalysisCaseUsage | AssignmentAction | Association | AttributeDefinition | AttributeUsage | Behavior | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | ClassificationExpression | Classifier | Comment | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectionUsageDecl | ConnectorDecl | ConstraintDefinition | ConstraintUsage | DataType | Dependency | Documentation | EnumerationDefinition | EnumerationUsage | ExposeElement | ExtentExpression | Feature | FeatureReferenceExpression | FeatureReferenceMember | FeatureTypeRef | FeatureTypingDecl | FlowConnectionDefinition | FlowConnectionUsageDecl | ForLoopAction | FunctionDecl | InlineAction | InlinePartDecl | Interaction | InterfaceDefinition | InterfaceUsageDecl | InvocationExpression | ItemDefinition | ItemFlowDecl | ItemUsage | MetadataBodyElement | MetadataDefinition | MetadataUsage | MetadataValue | OccurrenceDefinition | OccurrenceUsage | ParameterMember | PartDefinition | PartUsage | PerformAction | PortDefinition | PortUsage | Predicate | Redefinition | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | ReturnTypePart | ReturnUsage | SendAction | Specialization | StateDefinition | StateUsage | Struct | Subclassification | SubjectUsage | Subsetting | SuccessionDecl | TransitionDecl | TriggerActionPart | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;
    readonly $type: 'QualifiedName';
    names: Array<NamePart>;
}

export const QualifiedName = 'QualifiedName';

export function isQualifiedName(item: unknown): item is QualifiedName {
    return reflection.isInstance(item, QualifiedName);
}

export interface RangeExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'RangeExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const RangeExpression = 'RangeExpression';

export function isRangeExpression(item: unknown): item is RangeExpression {
    return reflection.isInstance(item, RangeExpression);
}

export interface Redefinition extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | TypeBodyRule;
    readonly $type: 'Redefinition';
    name?: Name;
    redefinedFeature: QualifiedName;
    redefiningFeature: QualifiedName;
}

export const Redefinition = 'Redefinition';

export function isRedefinition(item: unknown): item is Redefinition {
    return reflection.isInstance(item, Redefinition);
}

export interface RelationalExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'RelationalExpression';
    left: OwnedExpression;
    operator: RelationalOperator;
    right: OwnedExpression;
}

export const RelationalExpression = 'RelationalExpression';

export function isRelationalExpression(item: unknown): item is RelationalExpression {
    return reflection.isInstance(item, RelationalExpression);
}

export interface RenderingDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'RenderingDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const RenderingDefinition = 'RenderingDefinition';

export function isRenderingDefinition(item: unknown): item is RenderingDefinition {
    return reflection.isInstance(item, RenderingDefinition);
}

export interface RenderingUsage extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition | ViewBodyRule;
    readonly $type: 'RenderingUsage' | 'TypeBodyRule';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const RenderingUsage = 'RenderingUsage';

export function isRenderingUsage(item: unknown): item is RenderingUsage {
    return reflection.isInstance(item, RenderingUsage);
}

export interface RequireConstraint extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'RequireConstraint';
    required: ConstraintUsage;
}

export const RequireConstraint = 'RequireConstraint';

export function isRequireConstraint(item: unknown): item is RequireConstraint {
    return reflection.isInstance(item, RequireConstraint);
}

export interface RequirementDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'RequirementDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    reqId?: string;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const RequirementDefinition = 'RequirementDefinition';

export function isRequirementDefinition(item: unknown): item is RequirementDefinition {
    return reflection.isInstance(item, RequirementDefinition);
}

export interface RequirementUsage extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'RequirementUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const RequirementUsage = 'RequirementUsage';

export function isRequirementUsage(item: unknown): item is RequirementUsage {
    return reflection.isInstance(item, RequirementUsage);
}

export interface ResultExpressionRule extends langium.AstNode {
    readonly $container: CalculationBodyRule;
    readonly $type: 'ResultExpressionRule';
    expression: OwnedExpression;
}

export const ResultExpressionRule = 'ResultExpressionRule';

export function isResultExpressionRule(item: unknown): item is ResultExpressionRule {
    return reflection.isInstance(item, ResultExpressionRule);
}

export interface ReturnUsage extends langium.AstNode {
    readonly $container: CalculationBodyRule;
    readonly $type: 'ReturnUsage';
    returnName?: Name;
    returnTypes: Array<QualifiedName>;
}

export const ReturnUsage = 'ReturnUsage';

export function isReturnUsage(item: unknown): item is ReturnUsage {
    return reflection.isInstance(item, ReturnUsage);
}

export interface RootNamespace extends langium.AstNode {
    readonly $type: 'RootNamespace';
    namespaceElements: Array<NamespaceElement>;
}

export const RootNamespace = 'RootNamespace';

export function isRootNamespace(item: unknown): item is RootNamespace {
    return reflection.isInstance(item, RootNamespace);
}

export interface SendAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'SendAction';
    payload: OwnedExpression;
    receiver: QualifiedName;
    via?: QualifiedName;
}

export const SendAction = 'SendAction';

export function isSendAction(item: unknown): item is SendAction {
    return reflection.isInstance(item, SendAction);
}

export interface Specialization extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | TypeBodyRule;
    readonly $type: 'Specialization';
    name?: Name;
    subtype: QualifiedName;
    supertype: QualifiedName;
}

export const Specialization = 'Specialization';

export function isSpecialization(item: unknown): item is Specialization {
    return reflection.isInstance(item, Specialization);
}

export interface StakeholderMember extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'StakeholderMember';
    inlineStakeholder?: InlinePartDecl;
    stakeholder?: PartUsage;
}

export const StakeholderMember = 'StakeholderMember';

export function isStakeholderMember(item: unknown): item is StakeholderMember {
    return reflection.isInstance(item, StakeholderMember);
}

export interface StateDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'StateDefinition';
    body: StateBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isParallel: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const StateDefinition = 'StateDefinition';

export function isStateDefinition(item: unknown): item is StateDefinition {
    return reflection.isInstance(item, StateDefinition);
}

export interface StateUsage extends langium.AstNode {
    readonly $container: OwningMembership | StateBodyRule | StateDefinition;
    readonly $type: 'StateBodyRule' | 'StateUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isParallel: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const StateUsage = 'StateUsage';

export function isStateUsage(item: unknown): item is StateUsage {
    return reflection.isInstance(item, StateUsage);
}

export interface Struct extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Struct' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const Struct = 'Struct';

export function isStruct(item: unknown): item is Struct {
    return reflection.isInstance(item, Struct);
}

export interface Subclassification extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | TypeBodyRule;
    readonly $type: 'Subclassification';
    name?: Name;
    subclassifier: QualifiedName;
    superclassifier: QualifiedName;
}

export const Subclassification = 'Subclassification';

export function isSubclassification(item: unknown): item is Subclassification {
    return reflection.isInstance(item, Subclassification);
}

export interface SubjectUsage extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'SubjectUsage';
    body: FeatureBodyRule;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    subjectTypes: Array<QualifiedName>;
}

export const SubjectUsage = 'SubjectUsage';

export function isSubjectUsage(item: unknown): item is SubjectUsage {
    return reflection.isInstance(item, SubjectUsage);
}

export interface Subsetting extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | TypeBodyRule;
    readonly $type: 'Subsetting';
    name?: Name;
    subsettedFeature: QualifiedName;
    subsettingFeature: QualifiedName;
}

export const Subsetting = 'Subsetting';

export function isSubsetting(item: unknown): item is Subsetting {
    return reflection.isInstance(item, Subsetting);
}

export interface Succession extends langium.AstNode {
    readonly $type: 'Succession' | 'SuccessionDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}

export const Succession = 'Succession';

export function isSuccession(item: unknown): item is Succession {
    return reflection.isInstance(item, Succession);
}

export interface SuccessionUsage extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'SuccessionUsage';
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
    visibility?: VisibilityIndicator;
}

export const SuccessionUsage = 'SuccessionUsage';

export function isSuccessionUsage(item: unknown): item is SuccessionUsage {
    return reflection.isInstance(item, SuccessionUsage);
}

export interface TextualRepresentation extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'TextualRepresentation';
    body: string;
    language: string;
    name?: Name;
}

export const TextualRepresentation = 'TextualRepresentation';

export function isTextualRepresentation(item: unknown): item is TextualRepresentation {
    return reflection.isInstance(item, TextualRepresentation);
}

export interface TransitionUsage extends langium.AstNode {
    readonly $type: 'TransitionBodyRule' | 'TransitionDecl' | 'TransitionUsage';
    name?: Name;
}

export const TransitionUsage = 'TransitionUsage';

export function isTransitionUsage(item: unknown): item is TransitionUsage {
    return reflection.isInstance(item, TransitionUsage);
}

export interface TriggerActionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'TriggerActionPart';
    triggerPayload: QualifiedName;
}

export const TriggerActionPart = 'TriggerActionPart';

export function isTriggerActionPart(item: unknown): item is TriggerActionPart {
    return reflection.isInstance(item, TriggerActionPart);
}

export interface TypeDecl extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'TypeBodyRule' | 'TypeDecl';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const TypeDecl = 'TypeDecl';

export function isTypeDecl(item: unknown): item is TypeDecl {
    return reflection.isInstance(item, TypeDecl);
}

export interface UnaryExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'UnaryExpression';
    operand: OwnedExpression;
    operator: UnaryOperator;
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface UseCaseDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'UseCaseBodyRule' | 'UseCaseDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const UseCaseDefinition = 'UseCaseDefinition';

export function isUseCaseDefinition(item: unknown): item is UseCaseDefinition {
    return reflection.isInstance(item, UseCaseDefinition);
}

export interface UseCaseUsage extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'UseCaseBodyRule' | 'UseCaseUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const UseCaseUsage = 'UseCaseUsage';

export function isUseCaseUsage(item: unknown): item is UseCaseUsage {
    return reflection.isInstance(item, UseCaseUsage);
}

export interface VerificationCaseDefinition extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'ParameterListPart' | 'VerificationCaseDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const VerificationCaseDefinition = 'VerificationCaseDefinition';

export function isVerificationCaseDefinition(item: unknown): item is VerificationCaseDefinition {
    return reflection.isInstance(item, VerificationCaseDefinition);
}

export interface VerificationCaseUsage extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'ParameterListPart' | 'VerificationCaseUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const VerificationCaseUsage = 'VerificationCaseUsage';

export function isVerificationCaseUsage(item: unknown): item is VerificationCaseUsage {
    return reflection.isInstance(item, VerificationCaseUsage);
}

export interface ViewDefinition extends langium.AstNode {
    readonly $type: 'ViewBodyRule' | 'ViewDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ViewDefinition = 'ViewDefinition';

export function isViewDefinition(item: unknown): item is ViewDefinition {
    return reflection.isInstance(item, ViewDefinition);
}

export interface ViewpointDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'ViewpointDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}

export const ViewpointDefinition = 'ViewpointDefinition';

export function isViewpointDefinition(item: unknown): item is ViewpointDefinition {
    return reflection.isInstance(item, ViewpointDefinition);
}

export interface ViewpointUsage extends langium.AstNode {
    readonly $type: 'RequirementBodyRule' | 'ViewpointUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ViewpointUsage = 'ViewpointUsage';

export function isViewpointUsage(item: unknown): item is ViewpointUsage {
    return reflection.isInstance(item, ViewpointUsage);
}

export interface ViewUsage extends langium.AstNode {
    readonly $type: 'ViewBodyRule' | 'ViewUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}

export const ViewUsage = 'ViewUsage';

export function isViewUsage(item: unknown): item is ViewUsage {
    return reflection.isInstance(item, ViewUsage);
}

export interface WhileLoopAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'WhileLoopAction';
    body: ActionBodyRule;
    condition: OwnedExpression;
    untilCondition?: OwnedExpression;
}

export const WhileLoopAction = 'WhileLoopAction';

export function isWhileLoopAction(item: unknown): item is WhileLoopAction {
    return reflection.isInstance(item, WhileLoopAction);
}

export interface XorExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'XorExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}

export const XorExpression = 'XorExpression';

export function isXorExpression(item: unknown): item is XorExpression {
    return reflection.isInstance(item, XorExpression);
}

export interface ActionBodyRule extends ActionDefinition, ActionUsage {
    readonly $container: EffectActionPart | ForLoopAction | IfThenAction | WhileLoopAction;
    readonly $type: 'ActionBodyRule';
    elements: Array<ActionBodyElement>;
}

export const ActionBodyRule = 'ActionBodyRule';

export function isActionBodyRule(item: unknown): item is ActionBodyRule {
    return reflection.isInstance(item, ActionBodyRule);
}

export interface ParameterListPart extends ActionDefinition, ActionUsage, AnalysisCaseDefinition, AnalysisCaseUsage, CalculationDefinition, CalculationUsage, CaseDefinition, CaseUsage, ConcernDefinition, ConstraintDefinition, ConstraintUsage, RequirementDefinition, RequirementUsage, UseCaseDefinition, UseCaseUsage, VerificationCaseDefinition, VerificationCaseUsage, ViewpointDefinition {
    readonly $type: 'ParameterListPart';
    parameters: Array<ParameterMember>;
}

export const ParameterListPart = 'ParameterListPart';

export function isParameterListPart(item: unknown): item is ParameterListPart {
    return reflection.isInstance(item, ParameterListPart);
}

export interface TypeBodyRule extends AllocationDefinition, Association, Behavior, Class, Classifier, DataType, FunctionDecl, Interaction, MetadataDefinition, OccurrenceDefinition, Predicate, RenderingDefinition, RenderingUsage, Struct, TypeDecl {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | PartDefinition | PortDefinition;
    readonly $type: 'TypeBodyRule';
    elements: Array<TypeBodyElement>;
}

export const TypeBodyRule = 'TypeBodyRule';

export function isTypeBodyRule(item: unknown): item is TypeBodyRule {
    return reflection.isInstance(item, TypeBodyRule);
}

export interface AllocationUsageDecl extends AllocationUsage {
    readonly $type: 'AllocationUsageDecl';
    allocationTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}

export const AllocationUsageDecl = 'AllocationUsageDecl';

export function isAllocationUsageDecl(item: unknown): item is AllocationUsageDecl {
    return reflection.isInstance(item, AllocationUsageDecl);
}

export interface CaseBodyRule extends AnalysisCaseDefinition, AnalysisCaseUsage, CaseDefinition, CaseUsage, VerificationCaseDefinition, VerificationCaseUsage {
    readonly $type: 'CaseBodyRule';
    elements: Array<CaseBodyElement>;
}

export const CaseBodyRule = 'CaseBodyRule';

export function isCaseBodyRule(item: unknown): item is CaseBodyRule {
    return reflection.isInstance(item, CaseBodyRule);
}

export interface CalculationBodyRule extends CalculationDefinition, CalculationUsage {
    readonly $type: 'CalculationBodyRule';
    elements: Array<CalculationBodyElement>;
    result?: ResultExpressionRule;
}

export const CalculationBodyRule = 'CalculationBodyRule';

export function isCalculationBodyRule(item: unknown): item is CalculationBodyRule {
    return reflection.isInstance(item, CalculationBodyRule);
}

export interface ReturnTypePart extends CalculationDefinition, CalculationUsage {
    readonly $type: 'ReturnTypePart';
    returnName?: Name;
    returnTypes: Array<QualifiedName>;
}

export const ReturnTypePart = 'ReturnTypePart';

export function isReturnTypePart(item: unknown): item is ReturnTypePart {
    return reflection.isInstance(item, ReturnTypePart);
}

export interface RequirementBodyRule extends ConcernDefinition, ConcernUsage, RequirementDefinition, RequirementUsage, ViewpointDefinition, ViewpointUsage {
    readonly $type: 'RequirementBodyRule';
    elements: Array<RequirementBodyElement>;
}

export const RequirementBodyRule = 'RequirementBodyRule';

export function isRequirementBodyRule(item: unknown): item is RequirementBodyRule {
    return reflection.isInstance(item, RequirementBodyRule);
}

export interface ConnectionUsageDecl extends ConnectionUsage {
    readonly $type: 'ConnectionUsageDecl';
    connectionTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}

export const ConnectionUsageDecl = 'ConnectionUsageDecl';

export function isConnectionUsageDecl(item: unknown): item is ConnectionUsageDecl {
    return reflection.isInstance(item, ConnectionUsageDecl);
}

export interface ConnectorDecl extends Connector {
    readonly $type: 'ConnectorDecl';
    connectorTypes: Array<QualifiedName>;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}

export const ConnectorDecl = 'ConnectorDecl';

export function isConnectorDecl(item: unknown): item is ConnectorDecl {
    return reflection.isInstance(item, ConnectorDecl);
}

export interface ConstraintBodyRule extends ConstraintDefinition, ConstraintUsage {
    readonly $type: 'ConstraintBodyRule';
    constraintExpr?: OwnedExpression;
    elements: Array<ConstraintBodyElement>;
}

export const ConstraintBodyRule = 'ConstraintBodyRule';

export function isConstraintBodyRule(item: unknown): item is ConstraintBodyRule {
    return reflection.isInstance(item, ConstraintBodyRule);
}

export interface EnumerationBodyRule extends EnumerationDefinition {
    readonly $type: 'EnumerationBodyRule';
    elements: Array<NamespaceElement>;
    values: Array<EnumerationUsage>;
}

export const EnumerationBodyRule = 'EnumerationBodyRule';

export function isEnumerationBodyRule(item: unknown): item is EnumerationBodyRule {
    return reflection.isInstance(item, EnumerationBodyRule);
}

export interface FlowConnectionUsageDecl extends FlowConnectionUsage {
    readonly $type: 'FlowConnectionUsageDecl';
    flowTypes: Array<QualifiedName>;
    itemName?: Name;
    itemTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}

export const FlowConnectionUsageDecl = 'FlowConnectionUsageDecl';

export function isFlowConnectionUsageDecl(item: unknown): item is FlowConnectionUsageDecl {
    return reflection.isInstance(item, FlowConnectionUsageDecl);
}

export interface InterfaceUsageDecl extends InterfaceUsage {
    readonly $type: 'InterfaceUsageDecl';
    interfaceTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}

export const InterfaceUsageDecl = 'InterfaceUsageDecl';

export function isInterfaceUsageDecl(item: unknown): item is InterfaceUsageDecl {
    return reflection.isInstance(item, InterfaceUsageDecl);
}

export interface ItemFlowDecl extends ItemFlow {
    readonly $type: 'ItemFlowDecl';
    itemName?: Name;
    itemTypes: Array<QualifiedName>;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}

export const ItemFlowDecl = 'ItemFlowDecl';

export function isItemFlowDecl(item: unknown): item is ItemFlowDecl {
    return reflection.isInstance(item, ItemFlowDecl);
}

export interface PackageBody extends LibraryPackage, Package {
    readonly $type: 'PackageBody';
    elements: Array<NamespaceElement>;
}

export const PackageBody = 'PackageBody';

export function isPackageBody(item: unknown): item is PackageBody {
    return reflection.isInstance(item, PackageBody);
}

export interface StateBodyRule extends StateUsage {
    readonly $container: StateDefinition;
    readonly $type: 'StateBodyRule';
    elements: Array<StateBodyElement>;
}

export const StateBodyRule = 'StateBodyRule';

export function isStateBodyRule(item: unknown): item is StateBodyRule {
    return reflection.isInstance(item, StateBodyRule);
}

export interface SuccessionDecl extends Succession {
    readonly $type: 'SuccessionDecl';
    sourceEnd: ConnectorEnd;
    successionTypes: Array<QualifiedName>;
    targetEnds: Array<ConnectorEnd>;
}

export const SuccessionDecl = 'SuccessionDecl';

export function isSuccessionDecl(item: unknown): item is SuccessionDecl {
    return reflection.isInstance(item, SuccessionDecl);
}

export interface TransitionBodyRule extends TransitionUsage {
    readonly $type: 'TransitionBodyRule';
    elements: Array<NamespaceElement>;
}

export const TransitionBodyRule = 'TransitionBodyRule';

export function isTransitionBodyRule(item: unknown): item is TransitionBodyRule {
    return reflection.isInstance(item, TransitionBodyRule);
}

export interface TransitionDecl extends TransitionUsage {
    readonly $type: 'TransitionDecl';
    effect?: EffectActionPart;
    guard?: GuardExpressionPart;
    sourceState?: QualifiedName;
    targetState?: QualifiedName;
    trigger?: TriggerActionPart;
}

export const TransitionDecl = 'TransitionDecl';

export function isTransitionDecl(item: unknown): item is TransitionDecl {
    return reflection.isInstance(item, TransitionDecl);
}

export interface UseCaseBodyRule extends UseCaseDefinition, UseCaseUsage {
    readonly $type: 'UseCaseBodyRule';
    elements: Array<UseCaseBodyElement>;
}

export const UseCaseBodyRule = 'UseCaseBodyRule';

export function isUseCaseBodyRule(item: unknown): item is UseCaseBodyRule {
    return reflection.isInstance(item, UseCaseBodyRule);
}

export interface ViewBodyRule extends ViewDefinition, ViewUsage {
    readonly $type: 'ViewBodyRule';
    elements: Array<ViewBodyElement>;
}

export const ViewBodyRule = 'ViewBodyRule';

export function isViewBodyRule(item: unknown): item is ViewBodyRule {
    return reflection.isInstance(item, ViewBodyRule);
}

export type SysMLAstType = {
    AcceptAction: AcceptAction
    ActionBodyElement: ActionBodyElement
    ActionBodyRule: ActionBodyRule
    ActionDefinition: ActionDefinition
    ActionUsage: ActionUsage
    ActorMember: ActorMember
    AdditiveExpression: AdditiveExpression
    AliasMember: AliasMember
    Allocate: Allocate
    AllocationDefinition: AllocationDefinition
    AllocationUsage: AllocationUsage
    AllocationUsageDecl: AllocationUsageDecl
    AnalysisCaseDefinition: AnalysisCaseDefinition
    AnalysisCaseUsage: AnalysisCaseUsage
    AndExpression: AndExpression
    AssertConstraint: AssertConstraint
    AssignmentAction: AssignmentAction
    Association: Association
    AssumeConstraint: AssumeConstraint
    AttributeDefinition: AttributeDefinition
    AttributeUsage: AttributeUsage
    Behavior: Behavior
    BindingConnector: BindingConnector
    BodyExpression: BodyExpression
    CalculationBodyElement: CalculationBodyElement
    CalculationBodyRule: CalculationBodyRule
    CalculationDefinition: CalculationDefinition
    CalculationUsage: CalculationUsage
    CaseBodyElement: CaseBodyElement
    CaseBodyRule: CaseBodyRule
    CaseDefinition: CaseDefinition
    CaseUsage: CaseUsage
    Class: Class
    ClassificationExpression: ClassificationExpression
    Classifier: Classifier
    Comment: Comment
    ConcernDefinition: ConcernDefinition
    ConcernUsage: ConcernUsage
    ConditionalExpression: ConditionalExpression
    ConnectionDefinition: ConnectionDefinition
    ConnectionUsage: ConnectionUsage
    ConnectionUsageDecl: ConnectionUsageDecl
    Connector: Connector
    ConnectorDecl: ConnectorDecl
    ConnectorEnd: ConnectorEnd
    ConstraintBodyElement: ConstraintBodyElement
    ConstraintBodyRule: ConstraintBodyRule
    ConstraintDefinition: ConstraintDefinition
    ConstraintUsage: ConstraintUsage
    DataType: DataType
    Dependency: Dependency
    DoAction: DoAction
    Documentation: Documentation
    EffectActionPart: EffectActionPart
    Element: Element
    EntryAction: EntryAction
    EnumerationBodyRule: EnumerationBodyRule
    EnumerationDefinition: EnumerationDefinition
    EnumerationUsage: EnumerationUsage
    EqualityExpression: EqualityExpression
    ExitAction: ExitAction
    ExponentiationExpression: ExponentiationExpression
    ExposeElement: ExposeElement
    ExtentExpression: ExtentExpression
    Feature: Feature
    FeatureBodyElement: FeatureBodyElement
    FeatureBodyRule: FeatureBodyRule
    FeatureChainExpression: FeatureChainExpression
    FeatureChainRef: FeatureChainRef
    FeatureMember: FeatureMember
    FeatureReferenceExpression: FeatureReferenceExpression
    FeatureReferenceMember: FeatureReferenceMember
    FeatureTypeRef: FeatureTypeRef
    FeatureTypingDecl: FeatureTypingDecl
    FilterElement: FilterElement
    FlowConnectionDefinition: FlowConnectionDefinition
    FlowConnectionUsage: FlowConnectionUsage
    FlowConnectionUsageDecl: FlowConnectionUsageDecl
    ForLoopAction: ForLoopAction
    FramedConcern: FramedConcern
    FunctionDecl: FunctionDecl
    GuardExpressionPart: GuardExpressionPart
    IfThenAction: IfThenAction
    ImpliesExpression: ImpliesExpression
    Import: Import
    ImportReference: ImportReference
    IncludeUseCaseUsage: IncludeUseCaseUsage
    InlineAction: InlineAction
    InlinePartDecl: InlinePartDecl
    Interaction: Interaction
    InterfaceDefinition: InterfaceDefinition
    InterfaceUsage: InterfaceUsage
    InterfaceUsageDecl: InterfaceUsageDecl
    InvocationExpression: InvocationExpression
    ItemDefinition: ItemDefinition
    ItemFlow: ItemFlow
    ItemFlowDecl: ItemFlowDecl
    ItemUsage: ItemUsage
    LibraryPackage: LibraryPackage
    LiteralBoolean: LiteralBoolean
    LiteralDefault: LiteralDefault
    LiteralExpression: LiteralExpression
    LiteralInteger: LiteralInteger
    LiteralNull: LiteralNull
    LiteralReal: LiteralReal
    LiteralString: LiteralString
    LiteralValue: LiteralValue
    MetadataBodyElement: MetadataBodyElement
    MetadataBodyOpt: MetadataBodyOpt
    MetadataDefinition: MetadataDefinition
    MetadataUsage: MetadataUsage
    MetadataValue: MetadataValue
    MultiplicativeExpression: MultiplicativeExpression
    MultiplicityBounds: MultiplicityBounds
    NamespaceElement: NamespaceElement
    NullCoalescingExpression: NullCoalescingExpression
    ObjectiveMember: ObjectiveMember
    OccurrenceDefinition: OccurrenceDefinition
    OccurrenceUsage: OccurrenceUsage
    OrExpression: OrExpression
    OwnedExpression: OwnedExpression
    OwningMembership: OwningMembership
    Package: Package
    PackageBody: PackageBody
    ParameterListPart: ParameterListPart
    ParameterMember: ParameterMember
    PartDefinition: PartDefinition
    PartUsage: PartUsage
    PerformAction: PerformAction
    PortDefinition: PortDefinition
    PortUsage: PortUsage
    Predicate: Predicate
    QualifiedName: QualifiedName
    RangeExpression: RangeExpression
    Redefinition: Redefinition
    RelationalExpression: RelationalExpression
    RelationshipElement: RelationshipElement
    RenderingDefinition: RenderingDefinition
    RenderingUsage: RenderingUsage
    RequireConstraint: RequireConstraint
    RequirementBodyElement: RequirementBodyElement
    RequirementBodyRule: RequirementBodyRule
    RequirementDefinition: RequirementDefinition
    RequirementUsage: RequirementUsage
    ResultExpressionRule: ResultExpressionRule
    ReturnTypePart: ReturnTypePart
    ReturnUsage: ReturnUsage
    RootNamespace: RootNamespace
    SendAction: SendAction
    Specialization: Specialization
    StakeholderMember: StakeholderMember
    StateBodyElement: StateBodyElement
    StateBodyRule: StateBodyRule
    StateDefinition: StateDefinition
    StateUsage: StateUsage
    Struct: Struct
    Subclassification: Subclassification
    SubjectUsage: SubjectUsage
    Subsetting: Subsetting
    Succession: Succession
    SuccessionDecl: SuccessionDecl
    SuccessionUsage: SuccessionUsage
    TextualRepresentation: TextualRepresentation
    TransitionBodyRule: TransitionBodyRule
    TransitionDecl: TransitionDecl
    TransitionUsage: TransitionUsage
    TriggerActionPart: TriggerActionPart
    TypeBodyElement: TypeBodyElement
    TypeBodyRule: TypeBodyRule
    TypeDecl: TypeDecl
    UnaryExpression: UnaryExpression
    UseCaseBodyElement: UseCaseBodyElement
    UseCaseBodyRule: UseCaseBodyRule
    UseCaseDefinition: UseCaseDefinition
    UseCaseUsage: UseCaseUsage
    VerificationCaseDefinition: VerificationCaseDefinition
    VerificationCaseUsage: VerificationCaseUsage
    ViewBodyElement: ViewBodyElement
    ViewBodyRule: ViewBodyRule
    ViewDefinition: ViewDefinition
    ViewUsage: ViewUsage
    ViewpointDefinition: ViewpointDefinition
    ViewpointUsage: ViewpointUsage
    WhileLoopAction: WhileLoopAction
    XorExpression: XorExpression
}

export class SysMLAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [AcceptAction, ActionBodyElement, ActionBodyRule, ActionDefinition, ActionUsage, ActorMember, AdditiveExpression, AliasMember, Allocate, AllocationDefinition, AllocationUsage, AllocationUsageDecl, AnalysisCaseDefinition, AnalysisCaseUsage, AndExpression, AssertConstraint, AssignmentAction, Association, AssumeConstraint, AttributeDefinition, AttributeUsage, Behavior, BindingConnector, BodyExpression, CalculationBodyElement, CalculationBodyRule, CalculationDefinition, CalculationUsage, CaseBodyElement, CaseBodyRule, CaseDefinition, CaseUsage, Class, ClassificationExpression, Classifier, Comment, ConcernDefinition, ConcernUsage, ConditionalExpression, ConnectionDefinition, ConnectionUsage, ConnectionUsageDecl, Connector, ConnectorDecl, ConnectorEnd, ConstraintBodyElement, ConstraintBodyRule, ConstraintDefinition, ConstraintUsage, DataType, Dependency, DoAction, Documentation, EffectActionPart, Element, EntryAction, EnumerationBodyRule, EnumerationDefinition, EnumerationUsage, EqualityExpression, ExitAction, ExponentiationExpression, ExposeElement, ExtentExpression, Feature, FeatureBodyElement, FeatureBodyRule, FeatureChainExpression, FeatureChainRef, FeatureMember, FeatureReferenceExpression, FeatureReferenceMember, FeatureTypeRef, FeatureTypingDecl, FilterElement, FlowConnectionDefinition, FlowConnectionUsage, FlowConnectionUsageDecl, ForLoopAction, FramedConcern, FunctionDecl, GuardExpressionPart, IfThenAction, ImpliesExpression, Import, ImportReference, IncludeUseCaseUsage, InlineAction, InlinePartDecl, Interaction, InterfaceDefinition, InterfaceUsage, InterfaceUsageDecl, InvocationExpression, ItemDefinition, ItemFlow, ItemFlowDecl, ItemUsage, LibraryPackage, LiteralBoolean, LiteralDefault, LiteralExpression, LiteralInteger, LiteralNull, LiteralReal, LiteralString, LiteralValue, MetadataBodyElement, MetadataBodyOpt, MetadataDefinition, MetadataUsage, MetadataValue, MultiplicativeExpression, MultiplicityBounds, NamespaceElement, NullCoalescingExpression, ObjectiveMember, OccurrenceDefinition, OccurrenceUsage, OrExpression, OwnedExpression, OwningMembership, Package, PackageBody, ParameterListPart, ParameterMember, PartDefinition, PartUsage, PerformAction, PortDefinition, PortUsage, Predicate, QualifiedName, RangeExpression, Redefinition, RelationalExpression, RelationshipElement, RenderingDefinition, RenderingUsage, RequireConstraint, RequirementBodyElement, RequirementBodyRule, RequirementDefinition, RequirementUsage, ResultExpressionRule, ReturnTypePart, ReturnUsage, RootNamespace, SendAction, Specialization, StakeholderMember, StateBodyElement, StateBodyRule, StateDefinition, StateUsage, Struct, Subclassification, SubjectUsage, Subsetting, Succession, SuccessionDecl, SuccessionUsage, TextualRepresentation, TransitionBodyRule, TransitionDecl, TransitionUsage, TriggerActionPart, TypeBodyElement, TypeBodyRule, TypeDecl, UnaryExpression, UseCaseBodyElement, UseCaseBodyRule, UseCaseDefinition, UseCaseUsage, VerificationCaseDefinition, VerificationCaseUsage, ViewBodyElement, ViewBodyRule, ViewDefinition, ViewUsage, ViewpointDefinition, ViewpointUsage, WhileLoopAction, XorExpression];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AcceptAction:
            case AssertConstraint:
            case AssignmentAction:
            case ForLoopAction:
            case IfThenAction:
            case PerformAction:
            case SendAction:
            case SuccessionUsage:
            case WhileLoopAction: {
                return this.isSubtype(ActionBodyElement, supertype);
            }
            case ActionBodyRule: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(ActionUsage, supertype);
            }
            case ActionDefinition:
            case Allocate:
            case AllocationDefinition:
            case AllocationUsage:
            case AnalysisCaseDefinition:
            case AnalysisCaseUsage:
            case Association:
            case AttributeDefinition:
            case Behavior:
            case BindingConnector:
            case CalculationDefinition:
            case CalculationUsage:
            case CaseDefinition:
            case CaseUsage:
            case Class:
            case Classifier:
            case Comment:
            case ConcernDefinition:
            case ConcernUsage:
            case ConnectionDefinition:
            case ConnectionUsage:
            case Connector:
            case ConstraintDefinition:
            case DataType:
            case Dependency:
            case EnumerationDefinition:
            case EnumerationUsage:
            case Feature:
            case FlowConnectionDefinition:
            case FlowConnectionUsage:
            case FunctionDecl:
            case Interaction:
            case InterfaceDefinition:
            case InterfaceUsage:
            case ItemDefinition:
            case ItemFlow:
            case ItemUsage:
            case LibraryPackage:
            case MetadataDefinition:
            case MetadataUsage:
            case OccurrenceDefinition:
            case OccurrenceUsage:
            case Package:
            case PartDefinition:
            case PartUsage:
            case PortDefinition:
            case PortUsage:
            case Predicate:
            case RenderingDefinition:
            case RequirementDefinition:
            case StateDefinition:
            case Struct:
            case Succession:
            case TextualRepresentation:
            case TypeDecl:
            case UseCaseDefinition:
            case UseCaseUsage:
            case VerificationCaseDefinition:
            case VerificationCaseUsage:
            case ViewDefinition:
            case ViewpointDefinition:
            case ViewpointUsage: {
                return this.isSubtype(Element, supertype);
            }
            case ActionUsage: {
                return this.isSubtype(ActionBodyElement, supertype) || this.isSubtype(CalculationBodyElement, supertype) || this.isSubtype(CaseBodyElement, supertype) || this.isSubtype(Element, supertype) || this.isSubtype(UseCaseBodyElement, supertype);
            }
            case ActorMember:
            case ObjectiveMember:
            case SubjectUsage: {
                return this.isSubtype(CaseBodyElement, supertype) || this.isSubtype(RequirementBodyElement, supertype) || this.isSubtype(UseCaseBodyElement, supertype);
            }
            case AdditiveExpression:
            case AndExpression:
            case BodyExpression:
            case ClassificationExpression:
            case ConditionalExpression:
            case EqualityExpression:
            case ExponentiationExpression:
            case ExtentExpression:
            case FeatureChainExpression:
            case FeatureReferenceExpression:
            case ImpliesExpression:
            case InvocationExpression:
            case LiteralExpression:
            case MultiplicativeExpression:
            case NullCoalescingExpression:
            case OrExpression:
            case RangeExpression:
            case RelationalExpression:
            case UnaryExpression:
            case XorExpression: {
                return this.isSubtype(OwnedExpression, supertype);
            }
            case AliasMember:
            case Import:
            case OwningMembership: {
                return this.isSubtype(NamespaceElement, supertype);
            }
            case AllocationUsageDecl: {
                return this.isSubtype(AllocationUsage, supertype);
            }
            case AssumeConstraint:
            case FramedConcern:
            case RequireConstraint:
            case StakeholderMember: {
                return this.isSubtype(RequirementBodyElement, supertype);
            }
            case AttributeUsage: {
                return this.isSubtype(CalculationBodyElement, supertype) || this.isSubtype(ConstraintBodyElement, supertype) || this.isSubtype(Element, supertype);
            }
            case CalculationBodyRule:
            case ReturnTypePart: {
                return this.isSubtype(CalculationDefinition, supertype) || this.isSubtype(CalculationUsage, supertype);
            }
            case CaseBodyRule: {
                return this.isSubtype(AnalysisCaseDefinition, supertype) || this.isSubtype(AnalysisCaseUsage, supertype) || this.isSubtype(CaseDefinition, supertype) || this.isSubtype(CaseUsage, supertype) || this.isSubtype(VerificationCaseDefinition, supertype) || this.isSubtype(VerificationCaseUsage, supertype);
            }
            case ConnectionUsageDecl: {
                return this.isSubtype(ConnectionUsage, supertype);
            }
            case ConnectorDecl: {
                return this.isSubtype(Connector, supertype);
            }
            case ConstraintBodyRule: {
                return this.isSubtype(ConstraintDefinition, supertype) || this.isSubtype(ConstraintUsage, supertype);
            }
            case ConstraintUsage:
            case Documentation:
            case RequirementUsage: {
                return this.isSubtype(Element, supertype) || this.isSubtype(RequirementBodyElement, supertype);
            }
            case DoAction:
            case EntryAction:
            case ExitAction:
            case TransitionUsage: {
                return this.isSubtype(StateBodyElement, supertype);
            }
            case EnumerationBodyRule: {
                return this.isSubtype(EnumerationDefinition, supertype);
            }
            case ExposeElement:
            case FilterElement: {
                return this.isSubtype(ViewBodyElement, supertype);
            }
            case FeatureMember:
            case RelationshipElement: {
                return this.isSubtype(FeatureBodyElement, supertype) || this.isSubtype(TypeBodyElement, supertype);
            }
            case FeatureTypingDecl:
            case Redefinition:
            case Specialization:
            case Subclassification:
            case Subsetting: {
                return this.isSubtype(Element, supertype) || this.isSubtype(RelationshipElement, supertype);
            }
            case FlowConnectionUsageDecl: {
                return this.isSubtype(FlowConnectionUsage, supertype);
            }
            case IncludeUseCaseUsage: {
                return this.isSubtype(UseCaseBodyElement, supertype);
            }
            case InterfaceUsageDecl: {
                return this.isSubtype(InterfaceUsage, supertype);
            }
            case ItemFlowDecl: {
                return this.isSubtype(ItemFlow, supertype);
            }
            case LiteralBoolean:
            case LiteralDefault:
            case LiteralInteger:
            case LiteralNull:
            case LiteralReal:
            case LiteralString: {
                return this.isSubtype(LiteralExpression, supertype) || this.isSubtype(LiteralValue, supertype);
            }
            case LiteralValue: {
                return this.isSubtype(MetadataValue, supertype);
            }
            case NamespaceElement: {
                return this.isSubtype(ActionBodyElement, supertype) || this.isSubtype(CalculationBodyElement, supertype) || this.isSubtype(CaseBodyElement, supertype) || this.isSubtype(ConstraintBodyElement, supertype) || this.isSubtype(FeatureBodyElement, supertype) || this.isSubtype(RequirementBodyElement, supertype) || this.isSubtype(StateBodyElement, supertype) || this.isSubtype(TypeBodyElement, supertype) || this.isSubtype(UseCaseBodyElement, supertype) || this.isSubtype(ViewBodyElement, supertype);
            }
            case PackageBody: {
                return this.isSubtype(LibraryPackage, supertype) || this.isSubtype(Package, supertype);
            }
            case ParameterListPart: {
                return this.isSubtype(ActionDefinition, supertype) || this.isSubtype(ActionUsage, supertype) || this.isSubtype(AnalysisCaseDefinition, supertype) || this.isSubtype(AnalysisCaseUsage, supertype) || this.isSubtype(CalculationDefinition, supertype) || this.isSubtype(CalculationUsage, supertype) || this.isSubtype(CaseDefinition, supertype) || this.isSubtype(CaseUsage, supertype) || this.isSubtype(ConcernDefinition, supertype) || this.isSubtype(ConstraintDefinition, supertype) || this.isSubtype(ConstraintUsage, supertype) || this.isSubtype(RequirementDefinition, supertype) || this.isSubtype(RequirementUsage, supertype) || this.isSubtype(UseCaseDefinition, supertype) || this.isSubtype(UseCaseUsage, supertype) || this.isSubtype(VerificationCaseDefinition, supertype) || this.isSubtype(VerificationCaseUsage, supertype) || this.isSubtype(ViewpointDefinition, supertype);
            }
            case RenderingUsage:
            case ViewUsage: {
                return this.isSubtype(Element, supertype) || this.isSubtype(ViewBodyElement, supertype);
            }
            case RequirementBodyRule: {
                return this.isSubtype(ConcernDefinition, supertype) || this.isSubtype(ConcernUsage, supertype) || this.isSubtype(RequirementDefinition, supertype) || this.isSubtype(RequirementUsage, supertype) || this.isSubtype(ViewpointDefinition, supertype) || this.isSubtype(ViewpointUsage, supertype);
            }
            case ReturnUsage: {
                return this.isSubtype(CalculationBodyElement, supertype);
            }
            case StateBodyRule: {
                return this.isSubtype(StateUsage, supertype);
            }
            case StateUsage: {
                return this.isSubtype(Element, supertype) || this.isSubtype(StateBodyElement, supertype);
            }
            case SuccessionDecl: {
                return this.isSubtype(Succession, supertype);
            }
            case TransitionBodyRule:
            case TransitionDecl: {
                return this.isSubtype(TransitionUsage, supertype);
            }
            case TypeBodyRule: {
                return this.isSubtype(AllocationDefinition, supertype) || this.isSubtype(Association, supertype) || this.isSubtype(Behavior, supertype) || this.isSubtype(Class, supertype) || this.isSubtype(Classifier, supertype) || this.isSubtype(DataType, supertype) || this.isSubtype(FunctionDecl, supertype) || this.isSubtype(Interaction, supertype) || this.isSubtype(MetadataDefinition, supertype) || this.isSubtype(OccurrenceDefinition, supertype) || this.isSubtype(Predicate, supertype) || this.isSubtype(RenderingDefinition, supertype) || this.isSubtype(RenderingUsage, supertype) || this.isSubtype(Struct, supertype) || this.isSubtype(TypeDecl, supertype);
            }
            case UseCaseBodyRule: {
                return this.isSubtype(UseCaseDefinition, supertype) || this.isSubtype(UseCaseUsage, supertype);
            }
            case ViewBodyRule: {
                return this.isSubtype(ViewDefinition, supertype) || this.isSubtype(ViewUsage, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case AcceptAction: {
                return {
                    name: AcceptAction,
                    properties: [
                        { name: 'acceptName' },
                        { name: 'acceptTypes', defaultValue: [] },
                        { name: 'via' }
                    ]
                };
            }
            case ActionDefinition: {
                return {
                    name: ActionDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ActionUsage: {
                return {
                    name: ActionUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ActorMember: {
                return {
                    name: ActorMember,
                    properties: [
                        { name: 'actor' },
                        { name: 'inlineActor' }
                    ]
                };
            }
            case AdditiveExpression: {
                return {
                    name: AdditiveExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case AliasMember: {
                return {
                    name: AliasMember,
                    properties: [
                        { name: 'aliasName' },
                        { name: 'target' },
                        { name: 'visibility' }
                    ]
                };
            }
            case Allocate: {
                return {
                    name: Allocate,
                    properties: [
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' }
                    ]
                };
            }
            case AllocationDefinition: {
                return {
                    name: AllocationDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case AllocationUsage: {
                return {
                    name: AllocationUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case AnalysisCaseDefinition: {
                return {
                    name: AnalysisCaseDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case AnalysisCaseUsage: {
                return {
                    name: AnalysisCaseUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case AndExpression: {
                return {
                    name: AndExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case AssertConstraint: {
                return {
                    name: AssertConstraint,
                    properties: [
                        { name: 'asserted' },
                        { name: 'isNegated', defaultValue: false }
                    ]
                };
            }
            case AssignmentAction: {
                return {
                    name: AssignmentAction,
                    properties: [
                        { name: 'target' },
                        { name: 'value' }
                    ]
                };
            }
            case Association: {
                return {
                    name: Association,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isStruct', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case AssumeConstraint: {
                return {
                    name: AssumeConstraint,
                    properties: [
                        { name: 'assumed' }
                    ]
                };
            }
            case AttributeDefinition: {
                return {
                    name: AttributeDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case AttributeUsage: {
                return {
                    name: AttributeUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case Behavior: {
                return {
                    name: Behavior,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case BindingConnector: {
                return {
                    name: BindingConnector,
                    properties: [
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case BodyExpression: {
                return {
                    name: BodyExpression,
                    properties: [
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case CalculationDefinition: {
                return {
                    name: CalculationDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case CalculationUsage: {
                return {
                    name: CalculationUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case CaseDefinition: {
                return {
                    name: CaseDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case CaseUsage: {
                return {
                    name: CaseUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case Class: {
                return {
                    name: Class,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ClassificationExpression: {
                return {
                    name: ClassificationExpression,
                    properties: [
                        { name: 'classType' },
                        { name: 'operand' },
                        { name: 'operator' }
                    ]
                };
            }
            case Classifier: {
                return {
                    name: Classifier,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case Comment: {
                return {
                    name: Comment,
                    properties: [
                        { name: 'about', defaultValue: [] },
                        { name: 'body' },
                        { name: 'language' },
                        { name: 'name' }
                    ]
                };
            }
            case ConcernDefinition: {
                return {
                    name: ConcernDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConcernUsage: {
                return {
                    name: ConcernUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConditionalExpression: {
                return {
                    name: ConditionalExpression,
                    properties: [
                        { name: 'condition' },
                        { name: 'elseExpr' },
                        { name: 'thenExpr' }
                    ]
                };
            }
            case ConnectionDefinition: {
                return {
                    name: ConnectionDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConnectionUsage: {
                return {
                    name: ConnectionUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case Connector: {
                return {
                    name: Connector,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConnectorEnd: {
                return {
                    name: ConnectorEnd,
                    properties: [
                        { name: 'endName' },
                        { name: 'multiplicity' },
                        { name: 'target' }
                    ]
                };
            }
            case ConstraintDefinition: {
                return {
                    name: ConstraintDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConstraintUsage: {
                return {
                    name: ConstraintUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case DataType: {
                return {
                    name: DataType,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case Dependency: {
                return {
                    name: Dependency,
                    properties: [
                        { name: 'clients', defaultValue: [] },
                        { name: 'name' },
                        { name: 'suppliers', defaultValue: [] }
                    ]
                };
            }
            case DoAction: {
                return {
                    name: DoAction,
                    properties: [
                        { name: 'action' }
                    ]
                };
            }
            case Documentation: {
                return {
                    name: Documentation,
                    properties: [
                        { name: 'about', defaultValue: [] },
                        { name: 'body' },
                        { name: 'language' },
                        { name: 'name' }
                    ]
                };
            }
            case EffectActionPart: {
                return {
                    name: EffectActionPart,
                    properties: [
                        { name: 'effectAction' },
                        { name: 'effectBody' }
                    ]
                };
            }
            case EntryAction: {
                return {
                    name: EntryAction,
                    properties: [
                        { name: 'action' }
                    ]
                };
            }
            case EnumerationDefinition: {
                return {
                    name: EnumerationDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case EnumerationUsage: {
                return {
                    name: EnumerationUsage,
                    properties: [
                        { name: 'enumType' },
                        { name: 'name' }
                    ]
                };
            }
            case EqualityExpression: {
                return {
                    name: EqualityExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case ExitAction: {
                return {
                    name: ExitAction,
                    properties: [
                        { name: 'action' }
                    ]
                };
            }
            case ExponentiationExpression: {
                return {
                    name: ExponentiationExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case ExposeElement: {
                return {
                    name: ExposeElement,
                    properties: [
                        { name: 'exposed' }
                    ]
                };
            }
            case ExtentExpression: {
                return {
                    name: ExtentExpression,
                    properties: [
                        { name: 'extentType' }
                    ]
                };
            }
            case Feature: {
                return {
                    name: Feature,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case FeatureBodyRule: {
                return {
                    name: FeatureBodyRule,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case FeatureChainExpression: {
                return {
                    name: FeatureChainExpression,
                    properties: [
                        { name: 'members', defaultValue: [] },
                        { name: 'source' }
                    ]
                };
            }
            case FeatureChainRef: {
                return {
                    name: FeatureChainRef,
                    properties: [
                        { name: 'names', defaultValue: [] }
                    ]
                };
            }
            case FeatureMember: {
                return {
                    name: FeatureMember,
                    properties: [
                        { name: 'feature' },
                        { name: 'visibility' }
                    ]
                };
            }
            case FeatureReferenceExpression: {
                return {
                    name: FeatureReferenceExpression,
                    properties: [
                        { name: 'referent' }
                    ]
                };
            }
            case FeatureReferenceMember: {
                return {
                    name: FeatureReferenceMember,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'featureRef' }
                    ]
                };
            }
            case FeatureTypeRef: {
                return {
                    name: FeatureTypeRef,
                    properties: [
                        { name: 'isDefault', defaultValue: false },
                        { name: 'type' }
                    ]
                };
            }
            case FeatureTypingDecl: {
                return {
                    name: FeatureTypingDecl,
                    properties: [
                        { name: 'featureType' },
                        { name: 'name' },
                        { name: 'typedFeature' }
                    ]
                };
            }
            case FilterElement: {
                return {
                    name: FilterElement,
                    properties: [
                        { name: 'filterExpr' }
                    ]
                };
            }
            case FlowConnectionDefinition: {
                return {
                    name: FlowConnectionDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case FlowConnectionUsage: {
                return {
                    name: FlowConnectionUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ForLoopAction: {
                return {
                    name: ForLoopAction,
                    properties: [
                        { name: 'body' },
                        { name: 'loopVariable' },
                        { name: 'loopVariableType' },
                        { name: 'sequence' }
                    ]
                };
            }
            case FramedConcern: {
                return {
                    name: FramedConcern,
                    properties: [
                        { name: 'framedConcern' }
                    ]
                };
            }
            case FunctionDecl: {
                return {
                    name: FunctionDecl,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case GuardExpressionPart: {
                return {
                    name: GuardExpressionPart,
                    properties: [
                        { name: 'guardExpr' }
                    ]
                };
            }
            case IfThenAction: {
                return {
                    name: IfThenAction,
                    properties: [
                        { name: 'condition' },
                        { name: 'elseBody' },
                        { name: 'elseIf' },
                        { name: 'thenBody' }
                    ]
                };
            }
            case ImpliesExpression: {
                return {
                    name: ImpliesExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case Import: {
                return {
                    name: Import,
                    properties: [
                        { name: 'importRef' },
                        { name: 'isAll', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ImportReference: {
                return {
                    name: ImportReference,
                    properties: [
                        { name: 'isRecursive', defaultValue: false },
                        { name: 'isWildcard', defaultValue: false },
                        { name: 'names', defaultValue: [] }
                    ]
                };
            }
            case IncludeUseCaseUsage: {
                return {
                    name: IncludeUseCaseUsage,
                    properties: [
                        { name: 'included' }
                    ]
                };
            }
            case InlineAction: {
                return {
                    name: InlineAction,
                    properties: [
                        { name: 'actionName' },
                        { name: 'actionTypes', defaultValue: [] }
                    ]
                };
            }
            case InlinePartDecl: {
                return {
                    name: InlinePartDecl,
                    properties: [
                        { name: 'name' },
                        { name: 'types', defaultValue: [] }
                    ]
                };
            }
            case Interaction: {
                return {
                    name: Interaction,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case InterfaceDefinition: {
                return {
                    name: InterfaceDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case InterfaceUsage: {
                return {
                    name: InterfaceUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case InvocationExpression: {
                return {
                    name: InvocationExpression,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'invoked' }
                    ]
                };
            }
            case ItemDefinition: {
                return {
                    name: ItemDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ItemFlow: {
                return {
                    name: ItemFlow,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ItemUsage: {
                return {
                    name: ItemUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case LibraryPackage: {
                return {
                    name: LibraryPackage,
                    properties: [
                        { name: 'isStandard', defaultValue: false },
                        { name: 'name' }
                    ]
                };
            }
            case LiteralBoolean: {
                return {
                    name: LiteralBoolean,
                    properties: [
                        { name: 'value', defaultValue: false }
                    ]
                };
            }
            case LiteralInteger: {
                return {
                    name: LiteralInteger,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case LiteralReal: {
                return {
                    name: LiteralReal,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case LiteralString: {
                return {
                    name: LiteralString,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case MetadataBodyElement: {
                return {
                    name: MetadataBodyElement,
                    properties: [
                        { name: 'featureName' },
                        { name: 'featureType' },
                        { name: 'featureValue' }
                    ]
                };
            }
            case MetadataBodyOpt: {
                return {
                    name: MetadataBodyOpt,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case MetadataDefinition: {
                return {
                    name: MetadataDefinition,
                    properties: [
                        { name: 'about', defaultValue: [] },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case MetadataUsage: {
                return {
                    name: MetadataUsage,
                    properties: [
                        { name: 'atElements', defaultValue: [] },
                        { name: 'metadataElements', defaultValue: [] },
                        { name: 'metaTypes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case MetadataValue: {
                return {
                    name: MetadataValue,
                    properties: [
                        { name: 'valueRef' },
                        { name: 'values', defaultValue: [] }
                    ]
                };
            }
            case MultiplicativeExpression: {
                return {
                    name: MultiplicativeExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case MultiplicityBounds: {
                return {
                    name: MultiplicityBounds,
                    properties: [
                        { name: 'lowerBound' },
                        { name: 'upperBound' }
                    ]
                };
            }
            case NullCoalescingExpression: {
                return {
                    name: NullCoalescingExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case ObjectiveMember: {
                return {
                    name: ObjectiveMember,
                    properties: [
                        { name: 'objective' }
                    ]
                };
            }
            case OccurrenceDefinition: {
                return {
                    name: OccurrenceDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'lifecycleClass' },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case OccurrenceUsage: {
                return {
                    name: OccurrenceUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case OrExpression: {
                return {
                    name: OrExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case OwningMembership: {
                return {
                    name: OwningMembership,
                    properties: [
                        { name: 'element' },
                        { name: 'visibility' }
                    ]
                };
            }
            case Package: {
                return {
                    name: Package,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case ParameterMember: {
                return {
                    name: ParameterMember,
                    properties: [
                        { name: 'direction' },
                        { name: 'multiplicity' },
                        { name: 'paramName' },
                        { name: 'paramTypes', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false }
                    ]
                };
            }
            case PartDefinition: {
                return {
                    name: PartDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case PartUsage: {
                return {
                    name: PartUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isRef', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case PerformAction: {
                return {
                    name: PerformAction,
                    properties: [
                        { name: 'performed' },
                        { name: 'performedRef' }
                    ]
                };
            }
            case PortDefinition: {
                return {
                    name: PortDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isConjugated', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case PortUsage: {
                return {
                    name: PortUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isConjugated', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case Predicate: {
                return {
                    name: Predicate,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case QualifiedName: {
                return {
                    name: QualifiedName,
                    properties: [
                        { name: 'names', defaultValue: [] }
                    ]
                };
            }
            case RangeExpression: {
                return {
                    name: RangeExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case Redefinition: {
                return {
                    name: Redefinition,
                    properties: [
                        { name: 'name' },
                        { name: 'redefinedFeature' },
                        { name: 'redefiningFeature' }
                    ]
                };
            }
            case RelationalExpression: {
                return {
                    name: RelationalExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case RenderingDefinition: {
                return {
                    name: RenderingDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case RenderingUsage: {
                return {
                    name: RenderingUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case RequireConstraint: {
                return {
                    name: RequireConstraint,
                    properties: [
                        { name: 'required' }
                    ]
                };
            }
            case RequirementDefinition: {
                return {
                    name: RequirementDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'reqId' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case RequirementUsage: {
                return {
                    name: RequirementUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ResultExpressionRule: {
                return {
                    name: ResultExpressionRule,
                    properties: [
                        { name: 'expression' }
                    ]
                };
            }
            case ReturnUsage: {
                return {
                    name: ReturnUsage,
                    properties: [
                        { name: 'returnName' },
                        { name: 'returnTypes', defaultValue: [] }
                    ]
                };
            }
            case RootNamespace: {
                return {
                    name: RootNamespace,
                    properties: [
                        { name: 'namespaceElements', defaultValue: [] }
                    ]
                };
            }
            case SendAction: {
                return {
                    name: SendAction,
                    properties: [
                        { name: 'payload' },
                        { name: 'receiver' },
                        { name: 'via' }
                    ]
                };
            }
            case Specialization: {
                return {
                    name: Specialization,
                    properties: [
                        { name: 'name' },
                        { name: 'subtype' },
                        { name: 'supertype' }
                    ]
                };
            }
            case StakeholderMember: {
                return {
                    name: StakeholderMember,
                    properties: [
                        { name: 'inlineStakeholder' },
                        { name: 'stakeholder' }
                    ]
                };
            }
            case StateDefinition: {
                return {
                    name: StateDefinition,
                    properties: [
                        { name: 'body' },
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isParallel', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case StateUsage: {
                return {
                    name: StateUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isParallel', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case Struct: {
                return {
                    name: Struct,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case Subclassification: {
                return {
                    name: Subclassification,
                    properties: [
                        { name: 'name' },
                        { name: 'subclassifier' },
                        { name: 'superclassifier' }
                    ]
                };
            }
            case SubjectUsage: {
                return {
                    name: SubjectUsage,
                    properties: [
                        { name: 'body' },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'subjectTypes', defaultValue: [] }
                    ]
                };
            }
            case Subsetting: {
                return {
                    name: Subsetting,
                    properties: [
                        { name: 'name' },
                        { name: 'subsettedFeature' },
                        { name: 'subsettingFeature' }
                    ]
                };
            }
            case Succession: {
                return {
                    name: Succession,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'visibility' }
                    ]
                };
            }
            case SuccessionUsage: {
                return {
                    name: SuccessionUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case TextualRepresentation: {
                return {
                    name: TextualRepresentation,
                    properties: [
                        { name: 'body' },
                        { name: 'language' },
                        { name: 'name' }
                    ]
                };
            }
            case TransitionUsage: {
                return {
                    name: TransitionUsage,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case TriggerActionPart: {
                return {
                    name: TriggerActionPart,
                    properties: [
                        { name: 'triggerPayload' }
                    ]
                };
            }
            case TypeDecl: {
                return {
                    name: TypeDecl,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case UnaryExpression: {
                return {
                    name: UnaryExpression,
                    properties: [
                        { name: 'operand' },
                        { name: 'operator' }
                    ]
                };
            }
            case UseCaseDefinition: {
                return {
                    name: UseCaseDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case UseCaseUsage: {
                return {
                    name: UseCaseUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case VerificationCaseDefinition: {
                return {
                    name: VerificationCaseDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case VerificationCaseUsage: {
                return {
                    name: VerificationCaseUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ViewDefinition: {
                return {
                    name: ViewDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ViewpointDefinition: {
                return {
                    name: ViewpointDefinition,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case ViewpointUsage: {
                return {
                    name: ViewpointUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ViewUsage: {
                return {
                    name: ViewUsage,
                    properties: [
                        { name: 'direction' },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case WhileLoopAction: {
                return {
                    name: WhileLoopAction,
                    properties: [
                        { name: 'body' },
                        { name: 'condition' },
                        { name: 'untilCondition' }
                    ]
                };
            }
            case XorExpression: {
                return {
                    name: XorExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case ActionBodyRule: {
                return {
                    name: ActionBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ParameterListPart: {
                return {
                    name: ParameterListPart,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'parameters', defaultValue: [] },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'reqId' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case TypeBodyRule: {
                return {
                    name: TypeBodyRule,
                    properties: [
                        { name: 'about', defaultValue: [] },
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isStruct', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'lifecycleClass' },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case AllocationUsageDecl: {
                return {
                    name: AllocationUsageDecl,
                    properties: [
                        { name: 'allocationTypes', defaultValue: [] },
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case CaseBodyRule: {
                return {
                    name: CaseBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case CalculationBodyRule: {
                return {
                    name: CalculationBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'result' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ReturnTypePart: {
                return {
                    name: ReturnTypePart,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'returnName' },
                        { name: 'returnTypes', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case RequirementBodyRule: {
                return {
                    name: RequirementBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'reqId' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConnectionUsageDecl: {
                return {
                    name: ConnectionUsageDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'connectionTypes', defaultValue: [] },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConnectorDecl: {
                return {
                    name: ConnectorDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'connectorTypes', defaultValue: [] },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ConstraintBodyRule: {
                return {
                    name: ConstraintBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'constraintExpr' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case EnumerationBodyRule: {
                return {
                    name: EnumerationBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'values', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case FlowConnectionUsageDecl: {
                return {
                    name: FlowConnectionUsageDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'flowTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'itemName' },
                        { name: 'itemTypes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case InterfaceUsageDecl: {
                return {
                    name: InterfaceUsageDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'interfaceTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case ItemFlowDecl: {
                return {
                    name: ItemFlowDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'itemName' },
                        { name: 'itemTypes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'targetEnd' },
                        { name: 'visibility' }
                    ]
                };
            }
            case PackageBody: {
                return {
                    name: PackageBody,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'isStandard', defaultValue: false },
                        { name: 'name' }
                    ]
                };
            }
            case StateBodyRule: {
                return {
                    name: StateBodyRule,
                    properties: [
                        { name: 'direction' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isParallel', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case SuccessionDecl: {
                return {
                    name: SuccessionDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'direction' },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'name' },
                        { name: 'sourceEnd' },
                        { name: 'successionTypes', defaultValue: [] },
                        { name: 'targetEnds', defaultValue: [] },
                        { name: 'visibility' }
                    ]
                };
            }
            case TransitionBodyRule: {
                return {
                    name: TransitionBodyRule,
                    properties: [
                        { name: 'elements', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case TransitionDecl: {
                return {
                    name: TransitionDecl,
                    properties: [
                        { name: 'effect' },
                        { name: 'guard' },
                        { name: 'name' },
                        { name: 'sourceState' },
                        { name: 'targetState' },
                        { name: 'trigger' }
                    ]
                };
            }
            case UseCaseBodyRule: {
                return {
                    name: UseCaseBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            case ViewBodyRule: {
                return {
                    name: ViewBodyRule,
                    properties: [
                        { name: 'conjugatedType' },
                        { name: 'direction' },
                        { name: 'disjointTypes', defaultValue: [] },
                        { name: 'elements', defaultValue: [] },
                        { name: 'featureTypes', defaultValue: [] },
                        { name: 'isAbstract', defaultValue: false },
                        { name: 'isComposite', defaultValue: false },
                        { name: 'isDerived', defaultValue: false },
                        { name: 'isEnd', defaultValue: false },
                        { name: 'isPortion', defaultValue: false },
                        { name: 'isReadonly', defaultValue: false },
                        { name: 'isSufficient', defaultValue: false },
                        { name: 'multiplicity' },
                        { name: 'name' },
                        { name: 'redefines', defaultValue: [] },
                        { name: 'references', defaultValue: [] },
                        { name: 'specializations', defaultValue: [] },
                        { name: 'subsets', defaultValue: [] },
                        { name: 'valueBinding', defaultValue: false },
                        { name: 'valueComputed', defaultValue: false },
                        { name: 'valueDefault', defaultValue: false },
                        { name: 'valueExpression' },
                        { name: 'valueInitial', defaultValue: false },
                        { name: 'visibility' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new SysMLAstReflection();
