/******************************************************************************
 * This file was generated by langium-cli 3.5.2.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import * as langium from 'langium';
export declare const SysMLTerminals: {
    ID: RegExp;
    UNRESTRICTED_NAME: RegExp;
    STRING: RegExp;
    REAL: RegExp;
    INTEGER: RegExp;
    COMMENT_BODY: RegExp;
    ML_COMMENT: RegExp;
    SL_COMMENT: RegExp;
    WS: RegExp;
};
export type SysMLTerminalNames = keyof typeof SysMLTerminals;
export type SysMLKeywordNames = "!" | "!=" | "!==" | "#" | "%" | "&" | "(" | ")" | "*" | "**" | "+" | "," | "-" | "." | ".." | "/" | ":" | "::" | "::=" | ":=" | ":>" | ":>>" | ";" | "<" | "<=" | "=" | "==" | "===" | "=>" | ">" | ">=" | "?" | "??" | "@" | "[" | "]" | "^" | "about" | "abstract" | "accept" | "action" | "actor" | "alias" | "all" | "allocate" | "allocation" | "analysis" | "and" | "as" | "assert" | "assign" | "assoc" | "assume" | "attribute" | "behavior" | "binding" | "by" | "calc" | "case" | "class" | "classifier" | "comment" | "composite" | "concern" | "conjugate" | "connect" | "connection" | "connector" | "constraint" | "datatype" | "def" | "default" | "dependency" | "derived" | "disjoint" | "do" | "doc" | "else" | "end" | "entry" | "enum" | "exit" | "expose" | "false" | "feature" | "featuring" | "filter" | "first" | "flow" | "for" | "frame" | "from" | "function" | "hastype" | "if" | "implies" | "import" | "in" | "include" | "inout" | "interaction" | "interface" | "istype" | "item" | "language" | "library" | "lifecycle" | "meta" | "metadata" | "not" | "null" | "objective" | "occurrence" | "of" | "or" | "out" | "package" | "parallel" | "part" | "perform" | "port" | "portion" | "predicate" | "private" | "protected" | "public" | "readonly" | "redefines" | "redefinition" | "ref" | "references" | "rendering" | "rep" | "require" | "requirement" | "results" | "return" | "send" | "specialization" | "specializes" | "stakeholder" | "standard" | "state" | "struct" | "subclassification" | "subclassifier" | "subject" | "subset" | "subsets" | "subtype" | "succession" | "then" | "to" | "transition" | "true" | "type" | "typed" | "until" | "use" | "variant" | "verification" | "via" | "view" | "viewpoint" | "while" | "xor" | "{" | "|" | "}" | "~";
export type SysMLTokenNames = SysMLTerminalNames | SysMLKeywordNames;
export type ActionBodyElement = AcceptAction | ActionUsage | AssertConstraint | AssignmentAction | ForLoopAction | IfThenAction | NamespaceElement | PerformAction | SendAction | SuccessionUsage | WhileLoopAction;
export declare const ActionBodyElement = "ActionBodyElement";
export declare function isActionBodyElement(item: unknown): item is ActionBodyElement;
export type AdditiveOperator = '+' | '-';
export declare function isAdditiveOperator(item: unknown): item is AdditiveOperator;
export type CalculationBodyElement = ActionUsage | AttributeUsage | NamespaceElement | ReturnUsage;
export declare const CalculationBodyElement = "CalculationBodyElement";
export declare function isCalculationBodyElement(item: unknown): item is CalculationBodyElement;
export type CaseBodyElement = ActionUsage | ActorMember | NamespaceElement | ObjectiveMember | ResultsBlock | SubjectUsage;
export declare const CaseBodyElement = "CaseBodyElement";
export declare function isCaseBodyElement(item: unknown): item is CaseBodyElement;
export type ClassificationOperator = '@' | 'as' | 'hastype' | 'istype' | 'meta';
export declare function isClassificationOperator(item: unknown): item is ClassificationOperator;
export type ConstraintBodyElement = AttributeUsage | NamespaceElement;
export declare const ConstraintBodyElement = "ConstraintBodyElement";
export declare function isConstraintBodyElement(item: unknown): item is ConstraintBodyElement;
export type Element = ActionDefinition | ActionUsage | Allocate | AllocationDefinition | AllocationUsage | AnalysisCaseDefinition | AnalysisCaseUsage | Association | AttributeDefinition | AttributeUsage | Behavior | BindingConnector | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | Classifier | Comment | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectionUsage | Connector | ConstraintDefinition | ConstraintUsage | DataType | Dependency | Documentation | EnumerationDefinition | EnumerationUsage | Feature | FeatureTypingDecl | FlowConnectionDefinition | FlowConnectionUsage | FunctionDecl | Interaction | InterfaceDefinition | InterfaceUsage | ItemDefinition | ItemFlow | ItemUsage | LibraryPackage | MetadataDefinition | MetadataUsage | OccurrenceDefinition | OccurrenceUsage | Package | PartDefinition | PartUsage | PortDefinition | PortUsage | Predicate | Redefinition | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | Specialization | StateDefinition | StateUsage | Struct | Subclassification | Subsetting | Succession | TextualRepresentation | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;
export declare const Element = "Element";
export declare function isElement(item: unknown): item is Element;
export type EqualityOperator = '!=' | '!==' | '==' | '===';
export declare function isEqualityOperator(item: unknown): item is EqualityOperator;
export type FeatureBodyElement = FeatureMember | NamespaceElement | RelationshipElement;
export declare const FeatureBodyElement = "FeatureBodyElement";
export declare function isFeatureBodyElement(item: unknown): item is FeatureBodyElement;
export type FeatureDirectionKind = 'in' | 'inout' | 'out';
export declare function isFeatureDirectionKind(item: unknown): item is FeatureDirectionKind;
export type LiteralExpression = LiteralBoolean | LiteralDefault | LiteralInteger | LiteralNull | LiteralReal | LiteralString;
export declare const LiteralExpression = "LiteralExpression";
export declare function isLiteralExpression(item: unknown): item is LiteralExpression;
export type LiteralValue = LiteralBoolean | LiteralDefault | LiteralInteger | LiteralNull | LiteralReal | LiteralString;
export declare const LiteralValue = "LiteralValue";
export declare function isLiteralValue(item: unknown): item is LiteralValue;
export type MultiplicativeOperator = '%' | '*' | '/';
export declare function isMultiplicativeOperator(item: unknown): item is MultiplicativeOperator;
export type MultiplicityBoundValue = '*' | string;
export declare function isMultiplicityBoundValue(item: unknown): item is MultiplicityBoundValue;
export type Name = string;
export declare function isName(item: unknown): item is Name;
export type NamePart = string;
export declare function isNamePart(item: unknown): item is NamePart;
export type NamespaceElement = AliasMember | Import | OwningMembership;
export declare const NamespaceElement = "NamespaceElement";
export declare function isNamespaceElement(item: unknown): item is NamespaceElement;
export type OwnedExpression = AdditiveExpression | AndExpression | BodyExpression | ClassificationExpression | ConditionalExpression | EqualityExpression | ExponentiationExpression | ExtentExpression | FeatureChainExpression | FeatureReferenceExpression | ImpliesExpression | InvocationExpression | LiteralExpression | MultiplicativeExpression | NullCoalescingExpression | OrExpression | RangeExpression | RelationalExpression | UnaryExpression | XorExpression;
export declare const OwnedExpression = "OwnedExpression";
export declare function isOwnedExpression(item: unknown): item is OwnedExpression;
export type RelationalOperator = '<' | '<=' | '>' | '>=';
export declare function isRelationalOperator(item: unknown): item is RelationalOperator;
export type RelationshipElement = FeatureTypingDecl | Redefinition | Specialization | Subclassification | Subsetting;
export declare const RelationshipElement = "RelationshipElement";
export declare function isRelationshipElement(item: unknown): item is RelationshipElement;
export type RequirementBodyElement = ActorMember | AssumeConstraint | ConstraintUsage | Documentation | FramedConcern | NamespaceElement | ObjectiveMember | RequireConstraint | RequirementUsage | StakeholderMember | SubjectUsage;
export declare const RequirementBodyElement = "RequirementBodyElement";
export declare function isRequirementBodyElement(item: unknown): item is RequirementBodyElement;
export type StateBodyElement = DoAction | EntryAction | ExitAction | NamespaceElement | StateUsage | TransitionUsage;
export declare const StateBodyElement = "StateBodyElement";
export declare function isStateBodyElement(item: unknown): item is StateBodyElement;
export type TypeBodyElement = FeatureMember | NamespaceElement | RelationshipElement;
export declare const TypeBodyElement = "TypeBodyElement";
export declare function isTypeBodyElement(item: unknown): item is TypeBodyElement;
export type UnaryOperator = '!' | '+' | '-' | 'not' | '~';
export declare function isUnaryOperator(item: unknown): item is UnaryOperator;
export type UseCaseBodyElement = ActionUsage | ActorMember | IncludeUseCaseUsage | NamespaceElement | ObjectiveMember | SubjectUsage;
export declare const UseCaseBodyElement = "UseCaseBodyElement";
export declare function isUseCaseBodyElement(item: unknown): item is UseCaseBodyElement;
export type ViewBodyElement = ExposeElement | FilterElement | NamespaceElement | RenderingUsage | ViewUsage;
export declare const ViewBodyElement = "ViewBodyElement";
export declare function isViewBodyElement(item: unknown): item is ViewBodyElement;
export type VisibilityIndicator = 'private' | 'protected' | 'public';
export declare function isVisibilityIndicator(item: unknown): item is VisibilityIndicator;
export interface AcceptAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AcceptAction';
    acceptName?: Name;
    acceptTypes: Array<QualifiedName>;
    via?: QualifiedName;
}
export declare const AcceptAction = "AcceptAction";
export declare function isAcceptAction(item: unknown): item is AcceptAction;
export interface ActionDefinition extends langium.AstNode {
    readonly $type: 'ActionBodyRule' | 'ActionDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ActionDefinition = "ActionDefinition";
export declare function isActionDefinition(item: unknown): item is ActionDefinition;
export interface ActionUsage extends langium.AstNode {
    readonly $type: 'ActionBodyRule' | 'ActionUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ActionUsage = "ActionUsage";
export declare function isActionUsage(item: unknown): item is ActionUsage;
export interface ActorMember extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'ActorMember';
    actor?: PartUsage;
    inlineActor?: InlinePartDecl;
}
export declare const ActorMember = "ActorMember";
export declare function isActorMember(item: unknown): item is ActorMember;
export interface AdditiveExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'AdditiveExpression';
    left: OwnedExpression;
    operator: AdditiveOperator;
    right: OwnedExpression;
}
export declare const AdditiveExpression = "AdditiveExpression";
export declare function isAdditiveExpression(item: unknown): item is AdditiveExpression;
export interface AliasMember extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | ResultsBlock | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'AliasMember';
    aliasName: Name;
    target: QualifiedName;
    visibility?: VisibilityIndicator;
}
export declare const AliasMember = "AliasMember";
export declare function isAliasMember(item: unknown): item is AliasMember;
export interface Allocate extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Allocate';
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}
export declare const Allocate = "Allocate";
export declare function isAllocate(item: unknown): item is Allocate;
export interface AllocationDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'AllocationDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const AllocationDefinition = "AllocationDefinition";
export declare function isAllocationDefinition(item: unknown): item is AllocationDefinition;
export interface AllocationUsage extends langium.AstNode {
    readonly $type: 'AllocationUsage' | 'AllocationUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const AllocationUsage = "AllocationUsage";
export declare function isAllocationUsage(item: unknown): item is AllocationUsage;
export interface AnalysisCaseDefinition extends langium.AstNode {
    readonly $type: 'AnalysisCaseDefinition' | 'CaseBodyRule' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const AnalysisCaseDefinition = "AnalysisCaseDefinition";
export declare function isAnalysisCaseDefinition(item: unknown): item is AnalysisCaseDefinition;
export interface AnalysisCaseUsage extends langium.AstNode {
    readonly $type: 'AnalysisCaseUsage' | 'CaseBodyRule' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const AnalysisCaseUsage = "AnalysisCaseUsage";
export declare function isAnalysisCaseUsage(item: unknown): item is AnalysisCaseUsage;
export interface AndExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'AndExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const AndExpression = "AndExpression";
export declare function isAndExpression(item: unknown): item is AndExpression;
export interface AssertConstraint extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AssertConstraint';
    asserted: ConstraintUsage;
    isNegated: boolean;
}
export declare const AssertConstraint = "AssertConstraint";
export declare function isAssertConstraint(item: unknown): item is AssertConstraint;
export interface AssignmentAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'AssignmentAction';
    target: QualifiedName;
    value: OwnedExpression;
}
export declare const AssignmentAction = "AssignmentAction";
export declare function isAssignmentAction(item: unknown): item is AssignmentAction;
export interface Association extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Association' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isStruct: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Association = "Association";
export declare function isAssociation(item: unknown): item is Association;
export interface AssumeConstraint extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'AssumeConstraint';
    assumed: ConstraintUsage;
}
export declare const AssumeConstraint = "AssumeConstraint";
export declare function isAssumeConstraint(item: unknown): item is AssumeConstraint;
export interface AttributeDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'AttributeDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const AttributeDefinition = "AttributeDefinition";
export declare function isAttributeDefinition(item: unknown): item is AttributeDefinition;
export interface AttributeUsage extends langium.AstNode {
    readonly $container: CalculationBodyRule | ConstraintBodyRule | OwningMembership;
    readonly $type: 'AttributeUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const AttributeUsage = "AttributeUsage";
export declare function isAttributeUsage(item: unknown): item is AttributeUsage;
export interface Behavior extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Behavior' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Behavior = "Behavior";
export declare function isBehavior(item: unknown): item is Behavior;
export interface BindingConnector extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'BindingConnector';
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
    visibility?: VisibilityIndicator;
}
export declare const BindingConnector = "BindingConnector";
export declare function isBindingConnector(item: unknown): item is BindingConnector;
export interface BodyExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'BodyExpression';
    statements: Array<OwnedExpression>;
}
export declare const BodyExpression = "BodyExpression";
export declare function isBodyExpression(item: unknown): item is BodyExpression;
export interface CalculationDefinition extends langium.AstNode {
    readonly $type: 'CalculationBodyRule' | 'CalculationDefinition' | 'ParameterListPart' | 'ReturnTypePart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const CalculationDefinition = "CalculationDefinition";
export declare function isCalculationDefinition(item: unknown): item is CalculationDefinition;
export interface CalculationUsage extends langium.AstNode {
    readonly $type: 'CalculationBodyRule' | 'CalculationUsage' | 'ParameterListPart' | 'ReturnTypePart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const CalculationUsage = "CalculationUsage";
export declare function isCalculationUsage(item: unknown): item is CalculationUsage;
export interface CaseDefinition extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'CaseDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const CaseDefinition = "CaseDefinition";
export declare function isCaseDefinition(item: unknown): item is CaseDefinition;
export interface CaseUsage extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'CaseUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const CaseUsage = "CaseUsage";
export declare function isCaseUsage(item: unknown): item is CaseUsage;
export interface Class extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Class' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Class = "Class";
export declare function isClass(item: unknown): item is Class;
export interface ClassificationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ClassificationExpression';
    classType: QualifiedName;
    operand: OwnedExpression;
    operator: ClassificationOperator;
}
export declare const ClassificationExpression = "ClassificationExpression";
export declare function isClassificationExpression(item: unknown): item is ClassificationExpression;
export interface Classifier extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Classifier' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Classifier = "Classifier";
export declare function isClassifier(item: unknown): item is Classifier;
export interface Comment extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Comment';
    about: Array<QualifiedName>;
    body: string;
    language?: string;
    name?: Name;
}
export declare const Comment = "Comment";
export declare function isComment(item: unknown): item is Comment;
export interface ConcernDefinition extends langium.AstNode {
    readonly $type: 'ConcernDefinition' | 'ParameterListPart' | 'RequirementBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ConcernDefinition = "ConcernDefinition";
export declare function isConcernDefinition(item: unknown): item is ConcernDefinition;
export interface ConcernUsage extends langium.AstNode {
    readonly $type: 'ConcernUsage' | 'RequirementBodyRule';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ConcernUsage = "ConcernUsage";
export declare function isConcernUsage(item: unknown): item is ConcernUsage;
export interface ConditionalExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ConditionalExpression';
    condition: OwnedExpression;
    elseExpr: OwnedExpression;
    thenExpr: OwnedExpression;
}
export declare const ConditionalExpression = "ConditionalExpression";
export declare function isConditionalExpression(item: unknown): item is ConditionalExpression;
export interface ConnectionDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ConnectionDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ConnectionDefinition = "ConnectionDefinition";
export declare function isConnectionDefinition(item: unknown): item is ConnectionDefinition;
export interface ConnectionUsage extends langium.AstNode {
    readonly $type: 'ConnectionUsage' | 'ConnectionUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const ConnectionUsage = "ConnectionUsage";
export declare function isConnectionUsage(item: unknown): item is ConnectionUsage;
export interface Connector extends langium.AstNode {
    readonly $type: 'Connector' | 'ConnectorDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const Connector = "Connector";
export declare function isConnector(item: unknown): item is Connector;
export interface ConnectorEnd extends langium.AstNode {
    readonly $container: Allocate | AllocationUsageDecl | BindingConnector | ConnectionUsageDecl | ConnectorDecl | FlowConnectionUsageDecl | InterfaceUsageDecl | ItemFlowDecl | SuccessionDecl | SuccessionUsage;
    readonly $type: 'ConnectorEnd';
    endName?: Name;
    multiplicity?: MultiplicityBounds;
    target: FeatureChainRef;
}
export declare const ConnectorEnd = "ConnectorEnd";
export declare function isConnectorEnd(item: unknown): item is ConnectorEnd;
export interface ConstraintDefinition extends langium.AstNode {
    readonly $type: 'ConstraintBodyRule' | 'ConstraintDefinition' | 'ParameterListPart';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ConstraintDefinition = "ConstraintDefinition";
export declare function isConstraintDefinition(item: unknown): item is ConstraintDefinition;
export interface ConstraintUsage extends langium.AstNode {
    readonly $type: 'ConstraintBodyRule' | 'ConstraintUsage' | 'ParameterListPart';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ConstraintUsage = "ConstraintUsage";
export declare function isConstraintUsage(item: unknown): item is ConstraintUsage;
export interface DataType extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'DataType' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const DataType = "DataType";
export declare function isDataType(item: unknown): item is DataType;
export interface Dependency extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'Dependency';
    clients: Array<QualifiedName>;
    name?: Name;
    suppliers: Array<QualifiedName>;
}
export declare const Dependency = "Dependency";
export declare function isDependency(item: unknown): item is Dependency;
export interface DoAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'DoAction';
    action: ActionUsage;
}
export declare const DoAction = "DoAction";
export declare function isDoAction(item: unknown): item is DoAction;
export interface Documentation extends langium.AstNode {
    readonly $container: OwningMembership | RequirementBodyRule;
    readonly $type: 'Documentation';
    about: Array<QualifiedName>;
    body: string;
    language?: string;
    name?: Name;
}
export declare const Documentation = "Documentation";
export declare function isDocumentation(item: unknown): item is Documentation;
export interface EffectActionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'EffectActionPart';
    effectAction?: InlineAction;
    effectBody?: ActionBodyRule;
}
export declare const EffectActionPart = "EffectActionPart";
export declare function isEffectActionPart(item: unknown): item is EffectActionPart;
export interface EntryAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'EntryAction';
    action: ActionUsage;
}
export declare const EntryAction = "EntryAction";
export declare function isEntryAction(item: unknown): item is EntryAction;
export interface EnumerationDefinition extends langium.AstNode {
    readonly $type: 'EnumerationBodyRule' | 'EnumerationDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const EnumerationDefinition = "EnumerationDefinition";
export declare function isEnumerationDefinition(item: unknown): item is EnumerationDefinition;
export interface EnumerationUsage extends langium.AstNode {
    readonly $container: EnumerationBodyRule | OwningMembership;
    readonly $type: 'EnumerationUsage';
    enumType?: QualifiedName;
    name?: Name;
}
export declare const EnumerationUsage = "EnumerationUsage";
export declare function isEnumerationUsage(item: unknown): item is EnumerationUsage;
export interface EqualityExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'EqualityExpression';
    left: OwnedExpression;
    operator: EqualityOperator;
    right: OwnedExpression;
}
export declare const EqualityExpression = "EqualityExpression";
export declare function isEqualityExpression(item: unknown): item is EqualityExpression;
export interface ExitAction extends langium.AstNode {
    readonly $container: StateBodyRule;
    readonly $type: 'ExitAction';
    action: ActionUsage;
}
export declare const ExitAction = "ExitAction";
export declare function isExitAction(item: unknown): item is ExitAction;
export interface ExponentiationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ExponentiationExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const ExponentiationExpression = "ExponentiationExpression";
export declare function isExponentiationExpression(item: unknown): item is ExponentiationExpression;
export interface ExposeElement extends langium.AstNode {
    readonly $container: ViewBodyRule;
    readonly $type: 'ExposeElement';
    exposed: QualifiedName;
}
export declare const ExposeElement = "ExposeElement";
export declare function isExposeElement(item: unknown): item is ExposeElement;
export interface ExtentExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ExtentExpression';
    extentType: QualifiedName;
}
export declare const ExtentExpression = "ExtentExpression";
export declare function isExtentExpression(item: unknown): item is ExtentExpression;
export interface Feature extends langium.AstNode {
    readonly $container: FeatureMember | OwningMembership;
    readonly $type: 'Feature';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const Feature = "Feature";
export declare function isFeature(item: unknown): item is Feature;
export interface FeatureBodyRule extends langium.AstNode {
    readonly $container: AllocationUsage | AttributeUsage | ConnectionUsage | Connector | Feature | FlowConnectionUsage | InterfaceUsage | ItemFlow | ItemUsage | OccurrenceUsage | PartUsage | PortUsage | SubjectUsage | Succession;
    readonly $type: 'FeatureBodyRule';
    elements: Array<FeatureBodyElement>;
}
export declare const FeatureBodyRule = "FeatureBodyRule";
export declare function isFeatureBodyRule(item: unknown): item is FeatureBodyRule;
export interface FeatureChainExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'FeatureChainExpression';
    members: Array<FeatureReferenceMember>;
    source: OwnedExpression;
}
export declare const FeatureChainExpression = "FeatureChainExpression";
export declare function isFeatureChainExpression(item: unknown): item is FeatureChainExpression;
export interface FeatureChainRef extends langium.AstNode {
    readonly $container: ConnectorEnd;
    readonly $type: 'FeatureChainRef';
    names: Array<NamePart>;
}
export declare const FeatureChainRef = "FeatureChainRef";
export declare function isFeatureChainRef(item: unknown): item is FeatureChainRef;
export interface FeatureMember extends langium.AstNode {
    readonly $container: FeatureBodyRule | ResultsBlock | TypeBodyRule;
    readonly $type: 'FeatureMember';
    feature: Feature;
    visibility?: VisibilityIndicator;
}
export declare const FeatureMember = "FeatureMember";
export declare function isFeatureMember(item: unknown): item is FeatureMember;
export interface FeatureReferenceExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'FeatureReferenceExpression';
    referent: QualifiedName;
}
export declare const FeatureReferenceExpression = "FeatureReferenceExpression";
export declare function isFeatureReferenceExpression(item: unknown): item is FeatureReferenceExpression;
export interface FeatureReferenceMember extends langium.AstNode {
    readonly $container: FeatureChainExpression;
    readonly $type: 'FeatureReferenceMember';
    arguments: Array<OwnedExpression>;
    featureRef: QualifiedName;
}
export declare const FeatureReferenceMember = "FeatureReferenceMember";
export declare function isFeatureReferenceMember(item: unknown): item is FeatureReferenceMember;
export interface FeatureTypeRef extends langium.AstNode {
    readonly $container: ActionUsage | AnalysisCaseUsage | AttributeUsage | CalculationUsage | CaseUsage | ConcernUsage | ConstraintUsage | Feature | ItemUsage | OccurrenceUsage | PartUsage | PortUsage | RenderingUsage | RequirementUsage | StateUsage | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage;
    readonly $type: 'FeatureTypeRef';
    isDefault: boolean;
    type: QualifiedName;
}
export declare const FeatureTypeRef = "FeatureTypeRef";
export declare function isFeatureTypeRef(item: unknown): item is FeatureTypeRef;
export interface FeatureTypingDecl extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | ResultsBlock | TypeBodyRule;
    readonly $type: 'FeatureTypingDecl';
    featureType: QualifiedName;
    name?: Name;
    typedFeature: QualifiedName;
}
export declare const FeatureTypingDecl = "FeatureTypingDecl";
export declare function isFeatureTypingDecl(item: unknown): item is FeatureTypingDecl;
export interface FilterElement extends langium.AstNode {
    readonly $container: ViewBodyRule;
    readonly $type: 'FilterElement';
    filterExpr: OwnedExpression;
}
export declare const FilterElement = "FilterElement";
export declare function isFilterElement(item: unknown): item is FilterElement;
export interface FlowConnectionDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'FlowConnectionDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const FlowConnectionDefinition = "FlowConnectionDefinition";
export declare function isFlowConnectionDefinition(item: unknown): item is FlowConnectionDefinition;
export interface FlowConnectionUsage extends langium.AstNode {
    readonly $type: 'FlowConnectionUsage' | 'FlowConnectionUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const FlowConnectionUsage = "FlowConnectionUsage";
export declare function isFlowConnectionUsage(item: unknown): item is FlowConnectionUsage;
export interface ForLoopAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'ForLoopAction';
    body: ActionBodyRule;
    loopVariable: Name;
    loopVariableType?: QualifiedName;
    sequence: OwnedExpression;
}
export declare const ForLoopAction = "ForLoopAction";
export declare function isForLoopAction(item: unknown): item is ForLoopAction;
export interface FramedConcern extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'FramedConcern';
    framedConcern: ConcernUsage;
}
export declare const FramedConcern = "FramedConcern";
export declare function isFramedConcern(item: unknown): item is FramedConcern;
export interface FunctionDecl extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'FunctionDecl' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const FunctionDecl = "FunctionDecl";
export declare function isFunctionDecl(item: unknown): item is FunctionDecl;
export interface GuardExpressionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'GuardExpressionPart';
    guardExpr: OwnedExpression;
}
export declare const GuardExpressionPart = "GuardExpressionPart";
export declare function isGuardExpressionPart(item: unknown): item is GuardExpressionPart;
export interface IfThenAction extends langium.AstNode {
    readonly $container: ActionBodyRule | IfThenAction;
    readonly $type: 'IfThenAction';
    condition: OwnedExpression;
    elseBody?: ActionBodyRule;
    elseIf?: IfThenAction;
    thenBody: ActionBodyRule;
}
export declare const IfThenAction = "IfThenAction";
export declare function isIfThenAction(item: unknown): item is IfThenAction;
export interface ImpliesExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'ImpliesExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const ImpliesExpression = "ImpliesExpression";
export declare function isImpliesExpression(item: unknown): item is ImpliesExpression;
export interface Import extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | ResultsBlock | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'Import';
    importRef: ImportReference;
    isAll: boolean;
    visibility?: VisibilityIndicator;
}
export declare const Import = "Import";
export declare function isImport(item: unknown): item is Import;
export interface ImportReference extends langium.AstNode {
    readonly $container: Import;
    readonly $type: 'ImportReference';
    isRecursive: boolean;
    isWildcard: boolean;
    names: Array<NamePart>;
}
export declare const ImportReference = "ImportReference";
export declare function isImportReference(item: unknown): item is ImportReference;
export interface IncludeUseCaseUsage extends langium.AstNode {
    readonly $container: UseCaseBodyRule;
    readonly $type: 'IncludeUseCaseUsage';
    included: UseCaseUsage;
}
export declare const IncludeUseCaseUsage = "IncludeUseCaseUsage";
export declare function isIncludeUseCaseUsage(item: unknown): item is IncludeUseCaseUsage;
export interface InlineAction extends langium.AstNode {
    readonly $container: EffectActionPart;
    readonly $type: 'InlineAction';
    actionName?: Name;
    actionTypes: Array<QualifiedName>;
}
export declare const InlineAction = "InlineAction";
export declare function isInlineAction(item: unknown): item is InlineAction;
export interface InlinePartDecl extends langium.AstNode {
    readonly $container: ActorMember | StakeholderMember;
    readonly $type: 'InlinePartDecl';
    name?: Name;
    types: Array<QualifiedName>;
}
export declare const InlinePartDecl = "InlinePartDecl";
export declare function isInlinePartDecl(item: unknown): item is InlinePartDecl;
export interface Interaction extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Interaction' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Interaction = "Interaction";
export declare function isInteraction(item: unknown): item is Interaction;
export interface InterfaceDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'InterfaceDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const InterfaceDefinition = "InterfaceDefinition";
export declare function isInterfaceDefinition(item: unknown): item is InterfaceDefinition;
export interface InterfaceUsage extends langium.AstNode {
    readonly $type: 'InterfaceUsage' | 'InterfaceUsageDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const InterfaceUsage = "InterfaceUsage";
export declare function isInterfaceUsage(item: unknown): item is InterfaceUsage;
export interface InvocationExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'InvocationExpression';
    arguments: Array<OwnedExpression>;
    invoked: QualifiedName;
}
export declare const InvocationExpression = "InvocationExpression";
export declare function isInvocationExpression(item: unknown): item is InvocationExpression;
export interface ItemDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ItemDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ItemDefinition = "ItemDefinition";
export declare function isItemDefinition(item: unknown): item is ItemDefinition;
export interface ItemFlow extends langium.AstNode {
    readonly $type: 'ItemFlow' | 'ItemFlowDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const ItemFlow = "ItemFlow";
export declare function isItemFlow(item: unknown): item is ItemFlow;
export interface ItemUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'ItemUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ItemUsage = "ItemUsage";
export declare function isItemUsage(item: unknown): item is ItemUsage;
export interface LibraryPackage extends langium.AstNode {
    readonly $type: 'LibraryPackage' | 'PackageBody';
    isStandard: boolean;
    name?: Name;
}
export declare const LibraryPackage = "LibraryPackage";
export declare function isLibraryPackage(item: unknown): item is LibraryPackage;
export interface LiteralBoolean extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralBoolean';
    value: boolean;
}
export declare const LiteralBoolean = "LiteralBoolean";
export declare function isLiteralBoolean(item: unknown): item is LiteralBoolean;
export interface LiteralDefault extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralDefault';
}
export declare const LiteralDefault = "LiteralDefault";
export declare function isLiteralDefault(item: unknown): item is LiteralDefault;
export interface LiteralInteger extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralInteger';
    value: string;
}
export declare const LiteralInteger = "LiteralInteger";
export declare function isLiteralInteger(item: unknown): item is LiteralInteger;
export interface LiteralNull extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralNull';
}
export declare const LiteralNull = "LiteralNull";
export declare function isLiteralNull(item: unknown): item is LiteralNull;
export interface LiteralReal extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralReal';
    value: string;
}
export declare const LiteralReal = "LiteralReal";
export declare function isLiteralReal(item: unknown): item is LiteralReal;
export interface LiteralString extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'LiteralString';
    value: string;
}
export declare const LiteralString = "LiteralString";
export declare function isLiteralString(item: unknown): item is LiteralString;
export interface MetadataBodyElement extends langium.AstNode {
    readonly $container: MetadataBodyOpt | MetadataUsage;
    readonly $type: 'MetadataBodyElement';
    featureName: Name;
    featureType?: QualifiedName;
    featureValue: MetadataValue;
}
export declare const MetadataBodyElement = "MetadataBodyElement";
export declare function isMetadataBodyElement(item: unknown): item is MetadataBodyElement;
export interface MetadataBodyOpt extends langium.AstNode {
    readonly $type: 'MetadataBodyOpt';
    elements: Array<MetadataBodyElement>;
}
export declare const MetadataBodyOpt = "MetadataBodyOpt";
export declare function isMetadataBodyOpt(item: unknown): item is MetadataBodyOpt;
export interface MetadataDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'MetadataDefinition' | 'TypeBodyRule';
    about: Array<QualifiedName>;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const MetadataDefinition = "MetadataDefinition";
export declare function isMetadataDefinition(item: unknown): item is MetadataDefinition;
export interface MetadataUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'MetadataUsage';
    atElements: Array<MetadataBodyElement>;
    metadataElements: Array<MetadataBodyElement>;
    metaTypes: Array<QualifiedName>;
    name?: Name;
    type?: QualifiedName;
}
export declare const MetadataUsage = "MetadataUsage";
export declare function isMetadataUsage(item: unknown): item is MetadataUsage;
export interface MetadataValue extends langium.AstNode {
    readonly $container: MetadataBodyElement | MetadataValue;
    readonly $type: 'LiteralBoolean' | 'LiteralDefault' | 'LiteralInteger' | 'LiteralNull' | 'LiteralReal' | 'LiteralString' | 'LiteralValue' | 'MetadataValue';
    valueRef?: QualifiedName;
    values: Array<MetadataValue>;
}
export declare const MetadataValue = "MetadataValue";
export declare function isMetadataValue(item: unknown): item is MetadataValue;
export interface MultiplicativeExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'MultiplicativeExpression';
    left: OwnedExpression;
    operator: MultiplicativeOperator;
    right: OwnedExpression;
}
export declare const MultiplicativeExpression = "MultiplicativeExpression";
export declare function isMultiplicativeExpression(item: unknown): item is MultiplicativeExpression;
export interface MultiplicityBounds extends langium.AstNode {
    readonly $container: ActionDefinition | ActionUsage | AllocationDefinition | AnalysisCaseDefinition | AnalysisCaseUsage | Association | AttributeDefinition | AttributeUsage | Behavior | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | Classifier | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectorEnd | ConstraintDefinition | ConstraintUsage | DataType | EnumerationDefinition | Feature | FlowConnectionDefinition | FunctionDecl | Interaction | InterfaceDefinition | ItemDefinition | ItemUsage | MetadataDefinition | OccurrenceDefinition | OccurrenceUsage | ParameterMember | PartDefinition | PartUsage | PortDefinition | PortUsage | Predicate | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | StateDefinition | StateUsage | Struct | SubjectUsage | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;
    readonly $type: 'MultiplicityBounds';
    lowerBound?: MultiplicityBoundValue;
    upperBound: MultiplicityBoundValue;
}
export declare const MultiplicityBounds = "MultiplicityBounds";
export declare function isMultiplicityBounds(item: unknown): item is MultiplicityBounds;
export interface NullCoalescingExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'NullCoalescingExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const NullCoalescingExpression = "NullCoalescingExpression";
export declare function isNullCoalescingExpression(item: unknown): item is NullCoalescingExpression;
export interface ObjectiveMember extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'ObjectiveMember';
    objective: RequirementUsage;
}
export declare const ObjectiveMember = "ObjectiveMember";
export declare function isObjectiveMember(item: unknown): item is ObjectiveMember;
export interface OccurrenceDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'OccurrenceDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    lifecycleClass: QualifiedName;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const OccurrenceDefinition = "OccurrenceDefinition";
export declare function isOccurrenceDefinition(item: unknown): item is OccurrenceDefinition;
export interface OccurrenceUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'OccurrenceUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const OccurrenceUsage = "OccurrenceUsage";
export declare function isOccurrenceUsage(item: unknown): item is OccurrenceUsage;
export interface OrExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'OrExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const OrExpression = "OrExpression";
export declare function isOrExpression(item: unknown): item is OrExpression;
export interface OwningMembership extends langium.AstNode {
    readonly $container: ActionBodyRule | CalculationBodyRule | CaseBodyRule | ConstraintBodyRule | EnumerationBodyRule | FeatureBodyRule | PackageBody | RequirementBodyRule | ResultsBlock | RootNamespace | StateBodyRule | TransitionBodyRule | TypeBodyRule | UseCaseBodyRule | ViewBodyRule;
    readonly $type: 'OwningMembership';
    element: Element;
    visibility?: VisibilityIndicator;
}
export declare const OwningMembership = "OwningMembership";
export declare function isOwningMembership(item: unknown): item is OwningMembership;
export interface Package extends langium.AstNode {
    readonly $type: 'Package' | 'PackageBody';
    name?: Name;
}
export declare const Package = "Package";
export declare function isPackage(item: unknown): item is Package;
export interface ParameterMember extends langium.AstNode {
    readonly $container: ParameterListPart;
    readonly $type: 'ParameterMember';
    direction?: FeatureDirectionKind;
    multiplicity?: MultiplicityBounds;
    paramName?: Name;
    paramTypes: Array<QualifiedName>;
    valueBinding: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
}
export declare const ParameterMember = "ParameterMember";
export declare function isParameterMember(item: unknown): item is ParameterMember;
export interface PartDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PartDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const PartDefinition = "PartDefinition";
export declare function isPartDefinition(item: unknown): item is PartDefinition;
export interface PartUsage extends langium.AstNode {
    readonly $container: ActorMember | OwningMembership | StakeholderMember;
    readonly $type: 'PartUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    isRef: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const PartUsage = "PartUsage";
export declare function isPartUsage(item: unknown): item is PartUsage;
export interface PerformAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'PerformAction';
    performed?: ActionUsage;
    performedRef?: QualifiedName;
}
export declare const PerformAction = "PerformAction";
export declare function isPerformAction(item: unknown): item is PerformAction;
export interface PortDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PortDefinition';
    body: TypeBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isConjugated: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const PortDefinition = "PortDefinition";
export declare function isPortDefinition(item: unknown): item is PortDefinition;
export interface PortUsage extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'PortUsage';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isConjugated: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const PortUsage = "PortUsage";
export declare function isPortUsage(item: unknown): item is PortUsage;
export interface Predicate extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Predicate' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Predicate = "Predicate";
export declare function isPredicate(item: unknown): item is Predicate;
export interface QualifiedName extends langium.AstNode {
    readonly $container: AcceptAction | ActionDefinition | ActionUsage | AliasMember | AllocationDefinition | AllocationUsageDecl | AnalysisCaseDefinition | AnalysisCaseUsage | AssignmentAction | Association | AttributeDefinition | AttributeUsage | Behavior | CalculationDefinition | CalculationUsage | CaseDefinition | CaseUsage | Class | ClassificationExpression | Classifier | Comment | ConcernDefinition | ConcernUsage | ConnectionDefinition | ConnectionUsageDecl | ConnectorDecl | ConstraintDefinition | ConstraintUsage | DataType | Dependency | Documentation | EnumerationDefinition | EnumerationUsage | ExposeElement | ExtentExpression | Feature | FeatureReferenceExpression | FeatureReferenceMember | FeatureTypeRef | FeatureTypingDecl | FlowConnectionDefinition | FlowConnectionUsageDecl | ForLoopAction | FunctionDecl | InlineAction | InlinePartDecl | Interaction | InterfaceDefinition | InterfaceUsageDecl | InvocationExpression | ItemDefinition | ItemFlowDecl | ItemUsage | MetadataBodyElement | MetadataDefinition | MetadataUsage | MetadataValue | OccurrenceDefinition | OccurrenceUsage | ParameterMember | PartDefinition | PartUsage | PerformAction | PortDefinition | PortUsage | Predicate | Redefinition | RenderingDefinition | RenderingUsage | RequirementDefinition | RequirementUsage | ReturnTypePart | ReturnUsage | SendAction | Specialization | StateDefinition | StateUsage | Struct | Subclassification | SubjectUsage | Subsetting | SuccessionDecl | TransitionDecl | TriggerActionPart | TypeDecl | UseCaseDefinition | UseCaseUsage | VerificationCaseDefinition | VerificationCaseUsage | ViewDefinition | ViewUsage | ViewpointDefinition | ViewpointUsage;
    readonly $type: 'QualifiedName';
    names: Array<NamePart>;
}
export declare const QualifiedName = "QualifiedName";
export declare function isQualifiedName(item: unknown): item is QualifiedName;
export interface RangeExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'RangeExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const RangeExpression = "RangeExpression";
export declare function isRangeExpression(item: unknown): item is RangeExpression;
export interface Redefinition extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | ResultsBlock | TypeBodyRule;
    readonly $type: 'Redefinition';
    name?: Name;
    redefinedFeature: QualifiedName;
    redefiningFeature: QualifiedName;
}
export declare const Redefinition = "Redefinition";
export declare function isRedefinition(item: unknown): item is Redefinition;
export interface RelationalExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'RelationalExpression';
    left: OwnedExpression;
    operator: RelationalOperator;
    right: OwnedExpression;
}
export declare const RelationalExpression = "RelationalExpression";
export declare function isRelationalExpression(item: unknown): item is RelationalExpression;
export interface RenderingDefinition extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'RenderingDefinition' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const RenderingDefinition = "RenderingDefinition";
export declare function isRenderingDefinition(item: unknown): item is RenderingDefinition;
export interface RenderingUsage extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition | ViewBodyRule;
    readonly $type: 'RenderingUsage' | 'TypeBodyRule';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const RenderingUsage = "RenderingUsage";
export declare function isRenderingUsage(item: unknown): item is RenderingUsage;
export interface RequireConstraint extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'RequireConstraint';
    required: ConstraintUsage;
}
export declare const RequireConstraint = "RequireConstraint";
export declare function isRequireConstraint(item: unknown): item is RequireConstraint;
export interface RequirementDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'RequirementDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    reqId?: string;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const RequirementDefinition = "RequirementDefinition";
export declare function isRequirementDefinition(item: unknown): item is RequirementDefinition;
export interface RequirementUsage extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'RequirementUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const RequirementUsage = "RequirementUsage";
export declare function isRequirementUsage(item: unknown): item is RequirementUsage;
export interface ResultExpressionRule extends langium.AstNode {
    readonly $container: CalculationBodyRule;
    readonly $type: 'ResultExpressionRule';
    expression: OwnedExpression;
}
export declare const ResultExpressionRule = "ResultExpressionRule";
export declare function isResultExpressionRule(item: unknown): item is ResultExpressionRule;
export interface ResultsBlock extends langium.AstNode {
    readonly $container: CaseBodyRule;
    readonly $type: 'ResultsBlock';
    elements: Array<FeatureBodyElement>;
}
export declare const ResultsBlock = "ResultsBlock";
export declare function isResultsBlock(item: unknown): item is ResultsBlock;
export interface ReturnUsage extends langium.AstNode {
    readonly $container: CalculationBodyRule;
    readonly $type: 'ReturnUsage';
    returnName?: Name;
    returnTypes: Array<QualifiedName>;
}
export declare const ReturnUsage = "ReturnUsage";
export declare function isReturnUsage(item: unknown): item is ReturnUsage;
export interface RootNamespace extends langium.AstNode {
    readonly $type: 'RootNamespace';
    namespaceElements: Array<NamespaceElement>;
}
export declare const RootNamespace = "RootNamespace";
export declare function isRootNamespace(item: unknown): item is RootNamespace;
export interface SendAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'SendAction';
    payload: OwnedExpression;
    receiver: QualifiedName;
    via?: QualifiedName;
}
export declare const SendAction = "SendAction";
export declare function isSendAction(item: unknown): item is SendAction;
export interface Specialization extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | ResultsBlock | TypeBodyRule;
    readonly $type: 'Specialization';
    name?: Name;
    subtype: QualifiedName;
    supertype: QualifiedName;
}
export declare const Specialization = "Specialization";
export declare function isSpecialization(item: unknown): item is Specialization;
export interface StakeholderMember extends langium.AstNode {
    readonly $container: RequirementBodyRule;
    readonly $type: 'StakeholderMember';
    inlineStakeholder?: InlinePartDecl;
    stakeholder?: PartUsage;
}
export declare const StakeholderMember = "StakeholderMember";
export declare function isStakeholderMember(item: unknown): item is StakeholderMember;
export interface StateDefinition extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'StateDefinition';
    body: StateBodyRule;
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isParallel: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const StateDefinition = "StateDefinition";
export declare function isStateDefinition(item: unknown): item is StateDefinition;
export interface StateUsage extends langium.AstNode {
    readonly $container: OwningMembership | StateBodyRule | StateDefinition;
    readonly $type: 'StateBodyRule' | 'StateUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isParallel: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const StateUsage = "StateUsage";
export declare function isStateUsage(item: unknown): item is StateUsage;
export interface Struct extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'Struct' | 'TypeBodyRule';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const Struct = "Struct";
export declare function isStruct(item: unknown): item is Struct;
export interface Subclassification extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | ResultsBlock | TypeBodyRule;
    readonly $type: 'Subclassification';
    name?: Name;
    subclassifier: QualifiedName;
    superclassifier: QualifiedName;
}
export declare const Subclassification = "Subclassification";
export declare function isSubclassification(item: unknown): item is Subclassification;
export interface SubjectUsage extends langium.AstNode {
    readonly $container: CaseBodyRule | RequirementBodyRule | UseCaseBodyRule;
    readonly $type: 'SubjectUsage';
    body: FeatureBodyRule;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    subjectTypes: Array<QualifiedName>;
}
export declare const SubjectUsage = "SubjectUsage";
export declare function isSubjectUsage(item: unknown): item is SubjectUsage;
export interface Subsetting extends langium.AstNode {
    readonly $container: FeatureBodyRule | OwningMembership | ResultsBlock | TypeBodyRule;
    readonly $type: 'Subsetting';
    name?: Name;
    subsettedFeature: QualifiedName;
    subsettingFeature: QualifiedName;
}
export declare const Subsetting = "Subsetting";
export declare function isSubsetting(item: unknown): item is Subsetting;
export interface Succession extends langium.AstNode {
    readonly $type: 'Succession' | 'SuccessionDecl';
    body: FeatureBodyRule;
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    name?: Name;
    visibility?: VisibilityIndicator;
}
export declare const Succession = "Succession";
export declare function isSuccession(item: unknown): item is Succession;
export interface SuccessionUsage extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'SuccessionUsage';
    direction?: FeatureDirectionKind;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
    visibility?: VisibilityIndicator;
}
export declare const SuccessionUsage = "SuccessionUsage";
export declare function isSuccessionUsage(item: unknown): item is SuccessionUsage;
export interface TextualRepresentation extends langium.AstNode {
    readonly $container: OwningMembership;
    readonly $type: 'TextualRepresentation';
    body: string;
    language: string;
    name?: Name;
}
export declare const TextualRepresentation = "TextualRepresentation";
export declare function isTextualRepresentation(item: unknown): item is TextualRepresentation;
export interface TransitionUsage extends langium.AstNode {
    readonly $type: 'TransitionBodyRule' | 'TransitionDecl' | 'TransitionUsage';
    name?: Name;
}
export declare const TransitionUsage = "TransitionUsage";
export declare function isTransitionUsage(item: unknown): item is TransitionUsage;
export interface TriggerActionPart extends langium.AstNode {
    readonly $container: TransitionDecl;
    readonly $type: 'TriggerActionPart';
    triggerPayload: QualifiedName;
}
export declare const TriggerActionPart = "TriggerActionPart";
export declare function isTriggerActionPart(item: unknown): item is TriggerActionPart;
export interface TypeDecl extends langium.AstNode {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | OwningMembership | PartDefinition | PortDefinition;
    readonly $type: 'TypeBodyRule' | 'TypeDecl';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const TypeDecl = "TypeDecl";
export declare function isTypeDecl(item: unknown): item is TypeDecl;
export interface UnaryExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'UnaryExpression';
    operand: OwnedExpression;
    operator: UnaryOperator;
}
export declare const UnaryExpression = "UnaryExpression";
export declare function isUnaryExpression(item: unknown): item is UnaryExpression;
export interface UseCaseDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'UseCaseBodyRule' | 'UseCaseDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const UseCaseDefinition = "UseCaseDefinition";
export declare function isUseCaseDefinition(item: unknown): item is UseCaseDefinition;
export interface UseCaseUsage extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'UseCaseBodyRule' | 'UseCaseUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const UseCaseUsage = "UseCaseUsage";
export declare function isUseCaseUsage(item: unknown): item is UseCaseUsage;
export interface VerificationCaseDefinition extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'ParameterListPart' | 'VerificationCaseDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const VerificationCaseDefinition = "VerificationCaseDefinition";
export declare function isVerificationCaseDefinition(item: unknown): item is VerificationCaseDefinition;
export interface VerificationCaseUsage extends langium.AstNode {
    readonly $type: 'CaseBodyRule' | 'ParameterListPart' | 'VerificationCaseUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const VerificationCaseUsage = "VerificationCaseUsage";
export declare function isVerificationCaseUsage(item: unknown): item is VerificationCaseUsage;
export interface ViewDefinition extends langium.AstNode {
    readonly $type: 'ViewBodyRule' | 'ViewDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ViewDefinition = "ViewDefinition";
export declare function isViewDefinition(item: unknown): item is ViewDefinition;
export interface ViewpointDefinition extends langium.AstNode {
    readonly $type: 'ParameterListPart' | 'RequirementBodyRule' | 'ViewpointDefinition';
    conjugatedType?: QualifiedName;
    disjointTypes: Array<QualifiedName>;
    isAbstract: boolean;
    isSufficient: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    specializations: Array<QualifiedName>;
    visibility?: VisibilityIndicator;
}
export declare const ViewpointDefinition = "ViewpointDefinition";
export declare function isViewpointDefinition(item: unknown): item is ViewpointDefinition;
export interface ViewpointUsage extends langium.AstNode {
    readonly $type: 'RequirementBodyRule' | 'ViewpointUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ViewpointUsage = "ViewpointUsage";
export declare function isViewpointUsage(item: unknown): item is ViewpointUsage;
export interface ViewUsage extends langium.AstNode {
    readonly $type: 'ViewBodyRule' | 'ViewUsage';
    direction?: FeatureDirectionKind;
    featureTypes: Array<FeatureTypeRef>;
    isAbstract: boolean;
    isComposite: boolean;
    isDerived: boolean;
    isEnd: boolean;
    isPortion: boolean;
    isReadonly: boolean;
    multiplicity?: MultiplicityBounds;
    name?: Name;
    redefines: Array<QualifiedName>;
    references: Array<QualifiedName>;
    subsets: Array<QualifiedName>;
    valueBinding: boolean;
    valueComputed: boolean;
    valueDefault: boolean;
    valueExpression?: OwnedExpression;
    valueInitial: boolean;
    visibility?: VisibilityIndicator;
}
export declare const ViewUsage = "ViewUsage";
export declare function isViewUsage(item: unknown): item is ViewUsage;
export interface WhileLoopAction extends langium.AstNode {
    readonly $container: ActionBodyRule;
    readonly $type: 'WhileLoopAction';
    body: ActionBodyRule;
    condition: OwnedExpression;
    untilCondition?: OwnedExpression;
}
export declare const WhileLoopAction = "WhileLoopAction";
export declare function isWhileLoopAction(item: unknown): item is WhileLoopAction;
export interface XorExpression extends langium.AstNode {
    readonly $container: ActionUsage | AdditiveExpression | AnalysisCaseUsage | AndExpression | AssignmentAction | AttributeUsage | BodyExpression | CalculationUsage | CaseUsage | ClassificationExpression | ConcernUsage | ConditionalExpression | ConstraintBodyRule | ConstraintUsage | EqualityExpression | ExponentiationExpression | Feature | FeatureChainExpression | FeatureReferenceMember | FilterElement | ForLoopAction | GuardExpressionPart | IfThenAction | ImpliesExpression | InvocationExpression | ItemUsage | MultiplicativeExpression | NullCoalescingExpression | OccurrenceUsage | OrExpression | ParameterMember | PartUsage | PortUsage | RangeExpression | RelationalExpression | RenderingUsage | RequirementUsage | ResultExpressionRule | SendAction | StateUsage | UnaryExpression | UseCaseUsage | VerificationCaseUsage | ViewUsage | ViewpointUsage | WhileLoopAction | XorExpression;
    readonly $type: 'XorExpression';
    left: OwnedExpression;
    right: OwnedExpression;
}
export declare const XorExpression = "XorExpression";
export declare function isXorExpression(item: unknown): item is XorExpression;
export interface ActionBodyRule extends ActionDefinition, ActionUsage {
    readonly $container: EffectActionPart | ForLoopAction | IfThenAction | WhileLoopAction;
    readonly $type: 'ActionBodyRule';
    elements: Array<ActionBodyElement>;
}
export declare const ActionBodyRule = "ActionBodyRule";
export declare function isActionBodyRule(item: unknown): item is ActionBodyRule;
export interface ParameterListPart extends ActionDefinition, ActionUsage, AnalysisCaseDefinition, AnalysisCaseUsage, CalculationDefinition, CalculationUsage, CaseDefinition, CaseUsage, ConcernDefinition, ConstraintDefinition, ConstraintUsage, RequirementDefinition, RequirementUsage, UseCaseDefinition, UseCaseUsage, VerificationCaseDefinition, VerificationCaseUsage, ViewpointDefinition {
    readonly $type: 'ParameterListPart';
    parameters: Array<ParameterMember>;
}
export declare const ParameterListPart = "ParameterListPart";
export declare function isParameterListPart(item: unknown): item is ParameterListPart;
export interface TypeBodyRule extends AllocationDefinition, Association, Behavior, Class, Classifier, DataType, FunctionDecl, Interaction, MetadataDefinition, OccurrenceDefinition, Predicate, RenderingDefinition, RenderingUsage, Struct, TypeDecl {
    readonly $container: AttributeDefinition | ConnectionDefinition | FlowConnectionDefinition | InterfaceDefinition | ItemDefinition | PartDefinition | PortDefinition;
    readonly $type: 'TypeBodyRule';
    elements: Array<TypeBodyElement>;
}
export declare const TypeBodyRule = "TypeBodyRule";
export declare function isTypeBodyRule(item: unknown): item is TypeBodyRule;
export interface AllocationUsageDecl extends AllocationUsage {
    readonly $type: 'AllocationUsageDecl';
    allocationTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}
export declare const AllocationUsageDecl = "AllocationUsageDecl";
export declare function isAllocationUsageDecl(item: unknown): item is AllocationUsageDecl;
export interface CaseBodyRule extends AnalysisCaseDefinition, AnalysisCaseUsage, CaseDefinition, CaseUsage, VerificationCaseDefinition, VerificationCaseUsage {
    readonly $type: 'CaseBodyRule';
    elements: Array<CaseBodyElement>;
}
export declare const CaseBodyRule = "CaseBodyRule";
export declare function isCaseBodyRule(item: unknown): item is CaseBodyRule;
export interface CalculationBodyRule extends CalculationDefinition, CalculationUsage {
    readonly $type: 'CalculationBodyRule';
    elements: Array<CalculationBodyElement>;
    result?: ResultExpressionRule;
}
export declare const CalculationBodyRule = "CalculationBodyRule";
export declare function isCalculationBodyRule(item: unknown): item is CalculationBodyRule;
export interface ReturnTypePart extends CalculationDefinition, CalculationUsage {
    readonly $type: 'ReturnTypePart';
    returnName?: Name;
    returnTypes: Array<QualifiedName>;
}
export declare const ReturnTypePart = "ReturnTypePart";
export declare function isReturnTypePart(item: unknown): item is ReturnTypePart;
export interface RequirementBodyRule extends ConcernDefinition, ConcernUsage, RequirementDefinition, RequirementUsage, ViewpointDefinition, ViewpointUsage {
    readonly $type: 'RequirementBodyRule';
    elements: Array<RequirementBodyElement>;
}
export declare const RequirementBodyRule = "RequirementBodyRule";
export declare function isRequirementBodyRule(item: unknown): item is RequirementBodyRule;
export interface ConnectionUsageDecl extends ConnectionUsage {
    readonly $type: 'ConnectionUsageDecl';
    connectionTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}
export declare const ConnectionUsageDecl = "ConnectionUsageDecl";
export declare function isConnectionUsageDecl(item: unknown): item is ConnectionUsageDecl;
export interface ConnectorDecl extends Connector {
    readonly $type: 'ConnectorDecl';
    connectorTypes: Array<QualifiedName>;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}
export declare const ConnectorDecl = "ConnectorDecl";
export declare function isConnectorDecl(item: unknown): item is ConnectorDecl;
export interface ConstraintBodyRule extends ConstraintDefinition, ConstraintUsage {
    readonly $type: 'ConstraintBodyRule';
    constraintExpr?: OwnedExpression;
    elements: Array<ConstraintBodyElement>;
}
export declare const ConstraintBodyRule = "ConstraintBodyRule";
export declare function isConstraintBodyRule(item: unknown): item is ConstraintBodyRule;
export interface EnumerationBodyRule extends EnumerationDefinition {
    readonly $type: 'EnumerationBodyRule';
    elements: Array<NamespaceElement>;
    values: Array<EnumerationUsage>;
}
export declare const EnumerationBodyRule = "EnumerationBodyRule";
export declare function isEnumerationBodyRule(item: unknown): item is EnumerationBodyRule;
export interface FlowConnectionUsageDecl extends FlowConnectionUsage {
    readonly $type: 'FlowConnectionUsageDecl';
    flowTypes: Array<QualifiedName>;
    itemName?: Name;
    itemTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}
export declare const FlowConnectionUsageDecl = "FlowConnectionUsageDecl";
export declare function isFlowConnectionUsageDecl(item: unknown): item is FlowConnectionUsageDecl;
export interface InterfaceUsageDecl extends InterfaceUsage {
    readonly $type: 'InterfaceUsageDecl';
    interfaceTypes: Array<QualifiedName>;
    sourceEnd?: ConnectorEnd;
    targetEnd?: ConnectorEnd;
}
export declare const InterfaceUsageDecl = "InterfaceUsageDecl";
export declare function isInterfaceUsageDecl(item: unknown): item is InterfaceUsageDecl;
export interface ItemFlowDecl extends ItemFlow {
    readonly $type: 'ItemFlowDecl';
    itemName?: Name;
    itemTypes: Array<QualifiedName>;
    sourceEnd: ConnectorEnd;
    targetEnd: ConnectorEnd;
}
export declare const ItemFlowDecl = "ItemFlowDecl";
export declare function isItemFlowDecl(item: unknown): item is ItemFlowDecl;
export interface PackageBody extends LibraryPackage, Package {
    readonly $type: 'PackageBody';
    elements: Array<NamespaceElement>;
}
export declare const PackageBody = "PackageBody";
export declare function isPackageBody(item: unknown): item is PackageBody;
export interface StateBodyRule extends StateUsage {
    readonly $container: StateDefinition;
    readonly $type: 'StateBodyRule';
    elements: Array<StateBodyElement>;
}
export declare const StateBodyRule = "StateBodyRule";
export declare function isStateBodyRule(item: unknown): item is StateBodyRule;
export interface SuccessionDecl extends Succession {
    readonly $type: 'SuccessionDecl';
    sourceEnd: ConnectorEnd;
    successionTypes: Array<QualifiedName>;
    targetEnds: Array<ConnectorEnd>;
}
export declare const SuccessionDecl = "SuccessionDecl";
export declare function isSuccessionDecl(item: unknown): item is SuccessionDecl;
export interface TransitionBodyRule extends TransitionUsage {
    readonly $type: 'TransitionBodyRule';
    elements: Array<NamespaceElement>;
}
export declare const TransitionBodyRule = "TransitionBodyRule";
export declare function isTransitionBodyRule(item: unknown): item is TransitionBodyRule;
export interface TransitionDecl extends TransitionUsage {
    readonly $type: 'TransitionDecl';
    effect?: EffectActionPart;
    guard?: GuardExpressionPart;
    sourceState?: QualifiedName;
    targetState?: QualifiedName;
    trigger?: TriggerActionPart;
}
export declare const TransitionDecl = "TransitionDecl";
export declare function isTransitionDecl(item: unknown): item is TransitionDecl;
export interface UseCaseBodyRule extends UseCaseDefinition, UseCaseUsage {
    readonly $type: 'UseCaseBodyRule';
    elements: Array<UseCaseBodyElement>;
}
export declare const UseCaseBodyRule = "UseCaseBodyRule";
export declare function isUseCaseBodyRule(item: unknown): item is UseCaseBodyRule;
export interface ViewBodyRule extends ViewDefinition, ViewUsage {
    readonly $type: 'ViewBodyRule';
    elements: Array<ViewBodyElement>;
}
export declare const ViewBodyRule = "ViewBodyRule";
export declare function isViewBodyRule(item: unknown): item is ViewBodyRule;
export type SysMLAstType = {
    AcceptAction: AcceptAction;
    ActionBodyElement: ActionBodyElement;
    ActionBodyRule: ActionBodyRule;
    ActionDefinition: ActionDefinition;
    ActionUsage: ActionUsage;
    ActorMember: ActorMember;
    AdditiveExpression: AdditiveExpression;
    AliasMember: AliasMember;
    Allocate: Allocate;
    AllocationDefinition: AllocationDefinition;
    AllocationUsage: AllocationUsage;
    AllocationUsageDecl: AllocationUsageDecl;
    AnalysisCaseDefinition: AnalysisCaseDefinition;
    AnalysisCaseUsage: AnalysisCaseUsage;
    AndExpression: AndExpression;
    AssertConstraint: AssertConstraint;
    AssignmentAction: AssignmentAction;
    Association: Association;
    AssumeConstraint: AssumeConstraint;
    AttributeDefinition: AttributeDefinition;
    AttributeUsage: AttributeUsage;
    Behavior: Behavior;
    BindingConnector: BindingConnector;
    BodyExpression: BodyExpression;
    CalculationBodyElement: CalculationBodyElement;
    CalculationBodyRule: CalculationBodyRule;
    CalculationDefinition: CalculationDefinition;
    CalculationUsage: CalculationUsage;
    CaseBodyElement: CaseBodyElement;
    CaseBodyRule: CaseBodyRule;
    CaseDefinition: CaseDefinition;
    CaseUsage: CaseUsage;
    Class: Class;
    ClassificationExpression: ClassificationExpression;
    Classifier: Classifier;
    Comment: Comment;
    ConcernDefinition: ConcernDefinition;
    ConcernUsage: ConcernUsage;
    ConditionalExpression: ConditionalExpression;
    ConnectionDefinition: ConnectionDefinition;
    ConnectionUsage: ConnectionUsage;
    ConnectionUsageDecl: ConnectionUsageDecl;
    Connector: Connector;
    ConnectorDecl: ConnectorDecl;
    ConnectorEnd: ConnectorEnd;
    ConstraintBodyElement: ConstraintBodyElement;
    ConstraintBodyRule: ConstraintBodyRule;
    ConstraintDefinition: ConstraintDefinition;
    ConstraintUsage: ConstraintUsage;
    DataType: DataType;
    Dependency: Dependency;
    DoAction: DoAction;
    Documentation: Documentation;
    EffectActionPart: EffectActionPart;
    Element: Element;
    EntryAction: EntryAction;
    EnumerationBodyRule: EnumerationBodyRule;
    EnumerationDefinition: EnumerationDefinition;
    EnumerationUsage: EnumerationUsage;
    EqualityExpression: EqualityExpression;
    ExitAction: ExitAction;
    ExponentiationExpression: ExponentiationExpression;
    ExposeElement: ExposeElement;
    ExtentExpression: ExtentExpression;
    Feature: Feature;
    FeatureBodyElement: FeatureBodyElement;
    FeatureBodyRule: FeatureBodyRule;
    FeatureChainExpression: FeatureChainExpression;
    FeatureChainRef: FeatureChainRef;
    FeatureMember: FeatureMember;
    FeatureReferenceExpression: FeatureReferenceExpression;
    FeatureReferenceMember: FeatureReferenceMember;
    FeatureTypeRef: FeatureTypeRef;
    FeatureTypingDecl: FeatureTypingDecl;
    FilterElement: FilterElement;
    FlowConnectionDefinition: FlowConnectionDefinition;
    FlowConnectionUsage: FlowConnectionUsage;
    FlowConnectionUsageDecl: FlowConnectionUsageDecl;
    ForLoopAction: ForLoopAction;
    FramedConcern: FramedConcern;
    FunctionDecl: FunctionDecl;
    GuardExpressionPart: GuardExpressionPart;
    IfThenAction: IfThenAction;
    ImpliesExpression: ImpliesExpression;
    Import: Import;
    ImportReference: ImportReference;
    IncludeUseCaseUsage: IncludeUseCaseUsage;
    InlineAction: InlineAction;
    InlinePartDecl: InlinePartDecl;
    Interaction: Interaction;
    InterfaceDefinition: InterfaceDefinition;
    InterfaceUsage: InterfaceUsage;
    InterfaceUsageDecl: InterfaceUsageDecl;
    InvocationExpression: InvocationExpression;
    ItemDefinition: ItemDefinition;
    ItemFlow: ItemFlow;
    ItemFlowDecl: ItemFlowDecl;
    ItemUsage: ItemUsage;
    LibraryPackage: LibraryPackage;
    LiteralBoolean: LiteralBoolean;
    LiteralDefault: LiteralDefault;
    LiteralExpression: LiteralExpression;
    LiteralInteger: LiteralInteger;
    LiteralNull: LiteralNull;
    LiteralReal: LiteralReal;
    LiteralString: LiteralString;
    LiteralValue: LiteralValue;
    MetadataBodyElement: MetadataBodyElement;
    MetadataBodyOpt: MetadataBodyOpt;
    MetadataDefinition: MetadataDefinition;
    MetadataUsage: MetadataUsage;
    MetadataValue: MetadataValue;
    MultiplicativeExpression: MultiplicativeExpression;
    MultiplicityBounds: MultiplicityBounds;
    NamespaceElement: NamespaceElement;
    NullCoalescingExpression: NullCoalescingExpression;
    ObjectiveMember: ObjectiveMember;
    OccurrenceDefinition: OccurrenceDefinition;
    OccurrenceUsage: OccurrenceUsage;
    OrExpression: OrExpression;
    OwnedExpression: OwnedExpression;
    OwningMembership: OwningMembership;
    Package: Package;
    PackageBody: PackageBody;
    ParameterListPart: ParameterListPart;
    ParameterMember: ParameterMember;
    PartDefinition: PartDefinition;
    PartUsage: PartUsage;
    PerformAction: PerformAction;
    PortDefinition: PortDefinition;
    PortUsage: PortUsage;
    Predicate: Predicate;
    QualifiedName: QualifiedName;
    RangeExpression: RangeExpression;
    Redefinition: Redefinition;
    RelationalExpression: RelationalExpression;
    RelationshipElement: RelationshipElement;
    RenderingDefinition: RenderingDefinition;
    RenderingUsage: RenderingUsage;
    RequireConstraint: RequireConstraint;
    RequirementBodyElement: RequirementBodyElement;
    RequirementBodyRule: RequirementBodyRule;
    RequirementDefinition: RequirementDefinition;
    RequirementUsage: RequirementUsage;
    ResultExpressionRule: ResultExpressionRule;
    ResultsBlock: ResultsBlock;
    ReturnTypePart: ReturnTypePart;
    ReturnUsage: ReturnUsage;
    RootNamespace: RootNamespace;
    SendAction: SendAction;
    Specialization: Specialization;
    StakeholderMember: StakeholderMember;
    StateBodyElement: StateBodyElement;
    StateBodyRule: StateBodyRule;
    StateDefinition: StateDefinition;
    StateUsage: StateUsage;
    Struct: Struct;
    Subclassification: Subclassification;
    SubjectUsage: SubjectUsage;
    Subsetting: Subsetting;
    Succession: Succession;
    SuccessionDecl: SuccessionDecl;
    SuccessionUsage: SuccessionUsage;
    TextualRepresentation: TextualRepresentation;
    TransitionBodyRule: TransitionBodyRule;
    TransitionDecl: TransitionDecl;
    TransitionUsage: TransitionUsage;
    TriggerActionPart: TriggerActionPart;
    TypeBodyElement: TypeBodyElement;
    TypeBodyRule: TypeBodyRule;
    TypeDecl: TypeDecl;
    UnaryExpression: UnaryExpression;
    UseCaseBodyElement: UseCaseBodyElement;
    UseCaseBodyRule: UseCaseBodyRule;
    UseCaseDefinition: UseCaseDefinition;
    UseCaseUsage: UseCaseUsage;
    VerificationCaseDefinition: VerificationCaseDefinition;
    VerificationCaseUsage: VerificationCaseUsage;
    ViewBodyElement: ViewBodyElement;
    ViewBodyRule: ViewBodyRule;
    ViewDefinition: ViewDefinition;
    ViewUsage: ViewUsage;
    ViewpointDefinition: ViewpointDefinition;
    ViewpointUsage: ViewpointUsage;
    WhileLoopAction: WhileLoopAction;
    XorExpression: XorExpression;
};
export declare class SysMLAstReflection extends langium.AbstractAstReflection {
    getAllTypes(): string[];
    protected computeIsSubtype(subtype: string, supertype: string): boolean;
    getReferenceType(refInfo: langium.ReferenceInfo): string;
    getTypeMetaData(type: string): langium.TypeMetaData;
}
export declare const reflection: SysMLAstReflection;
//# sourceMappingURL=ast.d.ts.map